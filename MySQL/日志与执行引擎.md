# 日志与执行引擎

## 1. 日志

### 1.1 基本分类

+ `undo log`（回滚日志）：是InnoDB存储引擎生成的日志，实现了事务中的【原子性】，主要用于【事务回滚】和【MVCC】
+ `redo log`（重做日志）：是InnoDB存储引擎生成的日志，实现了事务中的【持久性】，主要用于【掉电等故障恢复】
+ `binlog`（归档日志）：是Server层生成的日志，主要用于【数据备份】和【主从复制】

### 1.2 什么是undo log

当事务对数据库进行更新（插入、修改、删除）时，系统会记录相应的`undo log`，以便在事务回滚或系统崩溃时进行数据恢复，主要用于事务回滚和MVCC。`undo log`记录的信息包括：

+ 操作类型（插入、删除还是更新）
+ 修改前的数据值
+ 被修改的数据的位置
+ 事务标识ID

比如在更新一条记录时，要把被更新的列的旧值记录下来，这样之后回滚时再把这些列更新为旧值就好了。

每一次更新操作产生的`undo log`格式都有一个`roll_pointer`指针（将undo log串成一个链表，链表也被称为版本链）和一个`trx_id`事务id（记录是被哪个事务修改的）

+ 事务回滚：如果事务在执行过程中出现错误或者被用户显式地回滚，系统可以使用`undo log`来还原事务所做的所有修改。通过`undo log`，数据库系统可以逆向执行事务的操作，将数据库还原到事务开始前的状态。
+ 实现MVCC关键因素之一。MVCC是通过Read View + undo log实现的。undo log为每条记录保存多份历史数据，MySQL在执行快照读（普通select语句）的时候，会根据事务的Read View里的信息，顺着`undo log`的版本链找到满足其可见性的记录。

### 1.3 什么是redo log

redo log是物理日志，记录某个数据页做了什么修改，比如对XXX表空间中的YYY数据页ZZZ偏移量的地方做了AAA更新。每当执行一个事务就会产生这样的一条或者多条物理日志。在事务提交时，只要先将redo log持久化道磁盘中即可。

### 1.4 redo log和undo log的区别

这两个日志都是InnoDB存储引擎生成的。

+ redo log记录了此次事务【完成后】的数据状态，记录的是【更新之后】的值；
+ undo log记录了此次事务【开始前】的数据状态，记录的是【更新之前】的值；

事务提交之前发生了崩溃，重启后会通过undo log回滚事务，事务提交之后发生了崩溃，重启后会通过redo log恢复事务。

### 1.5 什么是binlog

MySQL在完成一条更新操作后，Server层还会生成一条binlog，等之后事务提交的时候会将该事务执行过程中产生的所有binlog统一写入binlog文件。

binlog文件是记录了所有数据库表结构变更和表数据修改的日志，不会记录查询类的操作，比如SELECT和SHOW操作。

### 1.6 binlog和redo log的区别

+ 适用对象不同：binlog是MySQL的Server层实现的，所有存储引擎都可以使用；redo log是InnoDB存储引擎实现的日志。
+ 文件格式不同：redo log是物理日志，记录的是在某个数据页做了什么修改，比如对XXX表空间中的YYY数据页ZZZ偏移量的地方做了AAA更新。而binlog主要包括三种格式：Statement、Row和Mixed。
+ 写入方式不同：binlog是追加写，写满一个文件，就创建一个新的文件继续写，不会覆盖以前的日志，保存的是全量的日志。redo log是循环写，日志空间大小是固定的，全部写满就从头开始，保存未被刷入磁盘的脏页日志。
+ 用途不同：binlog用于备份恢复、主从恢复；redo log用于掉电等故障恢复。

### 1.7 为什么要两阶段提交

事务提交后，redo log和binlog都要持久化到磁盘，但是这两个是独立的逻辑，可能出现半成功的状态，造成两份日志之间的逻辑不一致。

+ 如果在将redo log刷入到磁盘之后，MySQL突然宕机，而binlog还没有来得及写入。MySQL重启后，通过redo log能将Buffer Poll值恢复到新值，但是binlog里面没有记录这条更新语句，在主从架构中，binlog会被复制到从库，由于binlog丢失了这条更新语句，从库的这一行是旧值，主从不一致。
+ 如果在将binlog刷入磁盘之后，MySQL突然宕机了，而redo log还没有来得及写入。由于redo log还没有写，崩溃恢复以后这个事务无效，数据是旧值，而binlog里面记录了这条更新语句，在主从架构中，binlog会被复制到从库，从库执行了这条更新语句，这一行字段是新值，与主库的值不一致。

所以会造成主从环境的数据不一致。因为redo log影响主库的数据，binlog影响从库的数据，redo log和binlog必须保持一致。

两阶段提交把单个事务的提交分为2个阶段，分别是准备和提交阶段，每个阶段都由协调者和参与者共同完成。

### 1.8 两阶段提交的过程

在MySQL的InnoDB存储引擎中，开启binlog的情况下，MySQL会同时维护binlog日志与InnoDB的redo log，为了保证这两个日志的一致性，MySQL使用了【内部XA事务】，内部XA事务由binlog作为协调者，存储引擎是参与者。

当客户端执行commit语句或者在自动提交的情况下，MySQL内部开启一个XA事务，分两阶段来完成XA事务的提交。

事务的提交过程有两个阶段，将redo log的写入拆成了两个步骤：prepare和commit，中间再穿插写入binlog

+ prepare阶段：将内部XA事务的ID写入到redo log，同时将redo log对应的事务状态设置为prepare，然后将redo log持久化道磁盘。
+ commit阶段：把内部XA事务的ID写入到binlog，然后将binlog持久化到磁盘，接着调用引擎的提交事务接口，将redo log状态设置为commit，此时该状态并不需要持久化道磁盘，只需要write到文件系统的page cache成功，只要binlog写磁盘成功，redo log的状态还是prepare页米有关系，一样会认为事务已经执行成功。

## 2. 执行引擎

### 2.1 有哪些执行引擎

在MySQL中，可以通过`SHOW ENGINES`查看当前数据库支持的存储引擎。InnoDB是较为通用和常用的存储引擎。

+ InnoDB：MySQL默认的事务性存储引擎，支持事务的提交和回滚，提供了行级锁定，支持外键约束和MVCC
+ MyISAM：使用表级锁定，不支持事务，支持全文索引，适用于以读操作为主的应用。
+ Memory：将数据放在内存中，数据处理速度很快，但是当数据库重启或者崩溃时，存储在内存中的数据将丢失。

### 2.2 InnoDB和MyISAM适用场景

+ 事务支持
  + InnoDB：支持事务，具有ACID特性，适合需要数据一致性和完整性的应用，比如银行系统或在线购物平台。
  + MyISAM：不支持事务，不具备ACID特性，适用于读密集、写少的场景，如博客系统或新闻网站。
+ 锁
  + InnoDB：行级锁，多个事务可以同时访问同一个表的不同行。
  + MyISAM：表级锁，对整个表进行锁定，导致并发性能下降，特别是在有大量写操作时。
+ 外键约束
  + InnoDB：支持外键约束，确保数据的一致性和完整性。
  + MyISAM：不支持外键约束。
+ 崩溃恢复
  + InnoDB：支持崩溃恢复。
  + MyISAM：在崩溃恢复可能会导致数据损失。
+ 全文索引
  + InnoDB：支持全文索引。
  + MyISAM：支持全文索引，并且更快。

总结：

+ InnoDB：适用于需要事务支持、并发性能好、具有高写入需求的应用。
+ MyISAM：适用于读操作频繁、写入操作较少的应用。