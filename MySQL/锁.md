# 锁

## 1. 全局锁

全局锁就是对整个数据库实例加锁。

典型使用场景：全库逻辑备份，即把整个库的表都select出来存成文本。

MySQL提供了一个加全局锁的方法：

```mysql
flush tables with read lock (FTWRL);
```

当你需要让整个库处于只读状态的时候，可以使用这个命令，之后其他线程的以下语句会被阻塞：

+ 数据更新语句（数据的增删改）
+ 数据定义语句（包括建表、修改表结构等）
+ 更新类事务的提交语句

## 2. 表级锁

（1）表锁

特点：

+ 每次操作锁住整张表
+ 开销小，加锁快
+ 并发度最低

表锁的语法是：`lock tables ... read/write`。

与`FTWRL`类似，可以用`unlock tables`主动释放锁，也可以在客户端断开的时候自动释放。

需要注意：lock tables语法除了会限制别的线程的读写外，也限定了本线程接下来的操作对象。

（2）元数据锁（meta data lock，MDL）

MDL不需要显式使用，在访问一个表的时候会被自动加上。

MDL的作用：保证读写的正确性。

你可以想象一下，如果一个查询正在遍历一个表中的数据，而执行期间另一个线程对这个表结构做更改，删了一列，那么查询线程拿到的结果和表结构对不上，肯定是不行的。

在MySQL 5.5版本中引入了MDL

+ 当对一个表做增删查改的时候，加MDL读锁；

+ 当要对表结构做变更操作的时候，加MDL写锁；

读锁之间不互斥，因此你可以有多个线程同时对一张表增删查改。读写锁之间，写锁是互斥的，用来保证变更表结构操作的安全性。因此，如果有两个线程要同时给一个表加字段，其中一个要等另一个执行完才能开始执行。

事务中的MDL锁，在语句执行开始是申请，但是语句结束后并不会马上释放，而是等到整个事务提交后再释放。（这可能会产生死锁的问题）

（3）意向锁

意向锁用于指示一个事务在未来可能会请求对某些资源（如数据行）的锁定。

+ 意向共享锁表示事务打算在资源上获得共享锁。其他事务可以继续获得共享锁，但不能获得排他锁。
+ 意向排他锁（独占）：表示事务打算在资源上获得排他锁。

对某些记录加上【共享锁】之前，需要先在表级别加上一个【意向共享锁】，对某些记录加上【独占锁】之前，需要先在表级别加上一个【意向独占锁】。

意向共享锁和意向独占锁是表级锁，不会和行级的共享锁和独占锁发生冲突，意向锁之前也不会发生冲突，只会和共享表锁和独占表锁发生冲突。意向锁目的是为了快速判断表里是否有记录被加锁。

（4）AUTO-INC锁

作用：表里的主键通常都会设置为自增的，之后可以在插入数据时，可以不指定主键的值，数据库会自动给主键赋值递增的值通过【AUTO-INC锁】实现。在插入数据时，会加一个表级别的AUTO-INC锁，然后为被【AUTO_INCREMENT】修饰的字段赋值递增的值，等插入语句执行后，才会把【AUTO-INC锁】释放。其他事务的如果要向该表插入语句都会被阻塞，从而保证插入数据时字段的值是连续递增的。

缺陷：对大量数据进行插入的时候，会影响插入性能，因为其他事务中的插入会被阻塞。

改进：InnoDB引擎提供了一种轻量级的锁来实现自增。在插入数据的时候，会为被【AUTO_INCREMENT】修饰的字段加上轻量级锁，然后给改】该字段赋值一个自增的值，就把这个轻量级锁释放了，而不需要等到整个插入语句执行完后才释放锁。

## 3. 行级锁

行锁就是针对数据表中行记录的锁（也有人称其为记录锁）。

比如事务A更新了一行，而这时候事务B也要更新同一行，则必须等待事务A的操作完成后才能进行更新。

类型：

+ Record Lock：记录锁，仅仅把一条记录锁上，记录锁分为共享锁和排他锁。
+ Gap Lock：间隙锁，锁定一个范围，但是不包含记录本身，只存在于可重复读隔离级别，目的是为了解决可重复读隔离级别下幻读的问题。间隙锁之间是兼容的，两个事务可以同时持有包含共同间隙范围的间隙锁，并不存在互斥关系。
+ Next-Key Lock：Record Lock + Gap Lock组合，锁定一个范围，并且锁定记录本身。next-key lcok既能保护该记录，又能阻止其他事务将新记录插入到被保护记录前面的间隙中。

特点：

+ 每次操作锁住一行数据
+ 开销大，加锁慢
+ 发生锁冲突的概率是最低的，并发度是最高的

在InnoDB事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束后才释放，这就是【两阶段锁协议】。

如果你的事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放。

加锁的两个原则和两个优化：

+ 两个原则
  + 加锁的基本单位是Next-Key Lock。它是前开后闭区间
  + 查找过程中访问到的对象才会加锁。
+ 两个优化
  + 索引上的等值查询，给唯一索引加锁的时候，Next-Key Lock就退化为行锁
  + 索引上的等值查询，向右遍历时且最后一个值不满足等值条件的时候，Next-Key Lock退化为间隙锁

以上规则是在可重复读隔离级别下验证的。同时，可重复读隔离级别遵守两阶段锁协议，所有加锁的资源，都是在事务提交或者回滚的时候才释放的。

## 4. 锁的划分

### 4.1 数据库角度

（1）共享锁（也叫读锁）

共享锁锁定的资源可以被其他用户读取，但不能修改。

在进行SELECT的时候，会将对象进行共享锁锁定，当数据读取完毕之后，就会释放共享锁，这样就可以保证数据在读取时不被修改。

举例：我们想要给某一行加上共享锁，比如想对user_id=10的数据行加上共享锁：

```mysql
SELECT user_id FROM product_comment WHERE user_id = 10 LOCK IN SHARE MODE;
```

（2）排他锁（也叫独占锁、写锁或X锁）

排他锁锁定的数据只允许进行锁定操作的事务使用，其他事务无法对已锁定的数据进行查询或修改。

举例：我们想要在某个数据行上添加排他锁，比如针对对user_id=10的数据行：

```mysql
SELECT user_id FROM product_comment WHERE user_id = 10 FOR UPDATE;
```

另外当我们对数据进行更新的时候，也就是INSERT、DELETE或者UPDATE的时候，数据库也会自动使用排他锁，防止其他事务对该数据行进行操作。

（3）共享锁与排他锁

共享锁与排他锁不仅可以锁住一行，还能锁住一张表。

比如我们想要给product_comment在表上加共享锁：

```mysql
LOCK TABLE product_comment READ;
```

如果我们想要对表上的共享锁进行解锁：

```mysql
UNLOCK TABLE;
```

如果我们想要给product_comment在表上加排他锁：

```mysql
LOCK TABLE product_comment WRITE;
```

释放：

```mysql
UNLOCK TABLE;
```

（4）意向锁

就是给更大一级别的空间示意里面是否已经上过锁。

你可以给整个房子设置一个标识，告诉它里面有人，即使你只是获取了房子中某一个房间的锁。这样其他人如果想要获取整个房子的控制权，只需要看这个房子的标识即可，不需要再对房子中的每个房间进行查找。十分方便。

如果我们给某一行数据加上了排他锁，数据库会自动给更大一级的空间，比如数据页或者数据表加上意向锁，告诉其他人这个数据页或者数据表已经有人上过排他锁了，这样当其他人想要获取数据表排他锁的时候，只需了解是否有人已经获取了这个数据表的意向排他锁即可。

如果事务想要获得数据表中某些记录的共享锁，就需要在数据表上添加意向共享锁。同理，事务想要获得数据表中某些记录排他锁，就需要在数据表上添加意向排他锁。这时，意向锁会告诉其他事务已经有人锁定了表中的某些记录，不能对整个表进行全表扫描。

### 4.2 程序员角度

（1）乐观锁

认为对同一数据的并发操作并不会总是发生，属于小概率事件，不用每次都对数据进行上锁，也就是不采用数据库自身的锁机制，而是通过程序来实现。在程序上，我们可以采用版本号机制或者时间戳机制实现。

（2）悲观锁

对数据被其他事务的修改持有保守态度，会通过数据库自身的锁机制来实现，从而保证数据操作的排他性。

（3）乐观锁和悲观锁的使用场景

+ 乐观锁
  + 适用于读操作多的场景，想对来说写的操作比较少。优点在于程序实现，不存在死锁问题，不过适用场景也会想对乐观，因为它阻止不了除了程序以外的数据库操作。
+ 悲观锁
  + 适用于写操作多的场景，因为写的操作具有排他性。采用悲观锁的方式，可以在数据库层面阻止其他事务对该数据的操作权限，防止读-写和写-写的冲突。但是加锁的时间会比较长，可能会长时间限制其他用户的访问，也就是说他的并发访问性不好。

## 5. InnoDB使用表锁还是行锁

绝大部分是使用行锁。

使用表锁的情况：

+ 表比较大，事务需要更新全部或者大部分数据
+ 事务涉及到多个表，比较复杂，可能引起死锁，造成大量的事务回滚