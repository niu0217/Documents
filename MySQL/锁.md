# 锁

## 1. 全局锁

全局锁就是对整个数据库实例加锁。

典型使用场景：全库逻辑备份，即把整个库的表都select出来存成文本。

MySQL提供了一个加全局锁的方法：

```mysql
flush tables with read lock (FTWRL);
```

当你需要让整个库处于只读状态的时候，可以使用这个命令，之后其他线程的以下语句会被阻塞：

+ 数据更新语句（数据的增删改）
+ 数据定义语句（包括建表、修改表结构等）
+ 更新类事务的提交语句

## 2. 表级锁

（1）表锁

特点：

+ 每次操作锁住整张表
+ 开销小，加锁快
+ 并发度最低

表锁的语法是：`lock tables ... read/write`。

与`FTWRL`类似，可以用`unlock tables`主动释放锁，也可以在客户端断开的时候自动释放。

需要注意：lock tables语法除了会限制别的线程的读写外，也限定了本线程接下来的操作对象。

（2）元数据锁（meta data lock，MDL）

MDL不需要显式使用，在访问一个表的时候会被自动加上。

MDL的作用：保证读写的正确性。

你可以想象一下，如果一个查询正在遍历一个表中的数据，而执行期间另一个线程对这个表结构做更改，删了一列，那么查询线程拿到的结果和表结构对不上，肯定是不行的。

在MySQL 5.5版本中引入了MDL

+ 当对一个表做增删查改的时候，加MDL读锁；

+ 当要对表结构做变更操作的时候，加MDL写锁；

读锁之间不互斥，因此你可以有多个线程同时对一张表增删查改。读写锁之间，写锁是互斥的，用来保证变更表结构操作的安全性。因此，如果有两个线程要同时给一个表加字段，其中一个要等另一个执行完才能开始执行。

事务中的MDL锁，在语句执行开始是申请，但是语句结束后并不会马上释放，而是等到整个事务提交后再释放。（这可能会产生死锁的问题）

（3）意向锁

意向锁用于指示一个事务在未来可能会请求对某些资源（如数据行）的锁定。

+ 意向共享锁表示事务打算在资源上获得共享锁。其他事务可以继续获得共享锁，但不能获得排他锁。
+ 意向排他锁（独占）：表示事务打算在资源上获得排他锁。

对某些记录加上【共享锁】之前，需要先在表级别加上一个【意向共享锁】，对某些记录加上【独占锁】之前，需要先在表级别加上一个【意向独占锁】。

意向共享锁和意向独占锁是表级锁，不会和行级的共享锁和独占锁发生冲突，意向锁之前也不会发生冲突，只会和共享表锁和独占表锁发生冲突。意向锁目的是为了快速判断表里是否有记录被加锁。

（4）AUTO-INC锁

## 3. 行级锁

