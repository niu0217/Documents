# unordered_set

## 1. 问题

## 2. 引入代码

```c++
#include <iostream>
#include <unordered_set>

int main() {
    // 1. 创建一个空的unordered_set，存储整型数据
    std::unordered_set<int> mySet;

    // 2. 插入元素 (Insertion)
    mySet.insert(3);
    mySet.insert({5, 7, 9});  // 可以一次插入多个元素

    // 3. 查找元素 (Search)
    if (mySet.find(5) != mySet.end()) {
        std::cout << "Element 5 is present in the set.\n";
    } else {
        std::cout << "Element 5 is not present in the set.\n";
    }

    // 4. 删除元素 (Deletion)
    auto it = mySet.find(3); // 找到元素
    if (it != mySet.end()) {
        mySet.erase(it);       // 删除找到的元素
    }
    // 或者直接删除指定元素，如果存在的话
    mySet.erase(7);

    // 5. 修改元素：由于unordered_set不允许修改已存在的元素，
    // 如果需要改变元素值，需要先删除再插入新值。

    // 6. 遍历 unordered_set (Traversal)
    for (const auto& value : mySet) {
        std::cout << "Value: " << value << '\n';
    }

    // 7. 清空 unordered_set (Clear)
    mySet.clear();

    return 0;
}
```

**注意**：

- `unordered_set`不支持通过索引访问元素。
- 元素是不能被修改的，因为它是常量引用迭代器返回的对象。如果要“修改”某个元素，实际上必须先删除原元素，然后插入新的元素。

其他函数包括但不限于：

- `size()` 返回集合中元素的数量。
- `empty()` 检查集合是否为空。
- `count(key)` 返回与给定键匹配的元素数量，在`unordered_set`中，要么为0要么为1。
- `emplace(args)` 直接在集合中构造并插入元素。
- `erase(key)` 删除所有与给定键相等的元素（在`unordered_set`中只有一个）。
- `swap(other)` 交换两个集合的内容。

## 3. 原理

`std::unordered_set`在C++ STL中的实现原理基于哈希表（Hash Table）。哈希表是一种可以提供常数时间平均复杂度插入、查找和删除操作的数据结构。下面是其主要工作原理：

1. **哈希函数**：每个元素都会通过一个哈希函数转换为一个哈希值，这个哈希值通常是一个整数值，用于确定元素在哈希表中的位置（即数组索引）。
2. **桶（Bucket）**：哈希表由一组桶组成，每个桶都可以包含零个或多个元素。当两个元素的哈希值相同（哈希冲突）时，它们会被存储在同一个桶内。
3. **解决冲突**：为了处理哈希冲突，`std::unordered_set`通常使用链地址法，即在一个桶中用链表连接所有哈希值相同的元素。这样即使出现哈希冲突，也能通过遍历链表找到正确的元素。
4. **负载因子**：为了维持良好的性能，`std::unordered_set`会动态调整内部哈希表的大小，以保持较低的负载因子（元素数量与桶数量之比）。当负载因子超过一定阈值时，容器会自动重新哈希所有元素到一个新的更大的哈希表中，从而降低冲突率。
5. **迭代器稳定性**：在`std::unordered_set`中进行插入和删除操作后，除了被删除元素的迭代器外，其他迭代器可能失效。这是因为重新哈希过程中元素的位置可能会发生变化。
6. **扩容策略**：STL库的具体实现可能不同，但一般来说，它会选择合适的时机进行扩容，比如当负载因子达到某个预设阈值时，会创建一个新的更大容量的哈希表，并将所有元素迁移到新表中，以保证查询效率。

综上所述，`std::unordered_set`利用哈希表数据结构实现了快速的增删查改操作，其具体性能取决于哈希函数的质量、负载因子以及解决冲突的方法等。

## 4. 优点和缺点

C++中`std::unordered_set`的优点：

1. **高效查找**：在理想情况下，通过哈希表实现的`std::unordered_set`插入、删除和查找操作的时间复杂度为O(1)（平均时间复杂度）。这是因为哈希函数将键直接映射到数组的位置，从而实现快速访问。
2. **空间效率**：虽然每个元素会额外存储指向下一个冲突元素的指针（当出现哈希冲突时），但整体上，如果哈希函数设计得当且负载因子合理，`std::unordered_set`仍能提供较好的空间效率。
3. **无序性**：`std::unordered_set`不保证元素的顺序，这对于仅需要查找、插入和删除而不关心元素顺序的应用场景非常有利，因为无需维护排序结构。
4. **迭代器遍历**：尽管元素的物理存储位置可能因插入和删除操作而改变，但可以通过迭代器来遍历所有元素。

缺点：

1. **哈希碰撞**：若哈希函数设计不佳或数据分布不均，可能会导致较多的哈希碰撞，从而降低查找、插入和删除操作的性能。最坏情况下，所有的元素都散列到同一个桶内，这时时间复杂度退化为O(n)。
2. **顺序不确定性**：由于是无序容器，不能依赖于元素的特定顺序进行操作。如果你的应用场景需要保持元素的有序性，应该使用`std::set`而非`std::unordered_set`。
3. **迭代器失效**：插入和删除操作可能导致其他元素的位置发生变化，因此除了当前被删除元素的迭代器外，其他迭代器可能在此过程中失效。
4. **初始化和重新哈希**：当容器需要扩容以降低负载因子时，需要对所有元素进行重新哈希并迁移至新的哈希表，这是一个耗时的过程，特别是在大量元素的情况下。
5. **空间浪费**：为了处理哈希碰撞，通常预留一些额外的空间，尤其是当负载因子较低时，可能会有较大的空间开销。

## 5. 增删查改的效率

在C++中，`std::unordered_set`基于哈希表实现，其增删查改操作的效率在理想情况下可以达到接近O(1)的时间复杂度：

1. **插入（Insertion）**：
   - 插入一个元素通常具有平均O(1)的时间复杂度。当通过哈希函数计算出的索引位置没有冲突时，可以直接插入新元素。如果出现哈希冲突，则需要在同一个桶内链接新元素，但这通常也是常数时间。
2. **查找（Search）**：
   - 查找一个元素同样具有平均O(1)的时间复杂度。首先通过哈希函数快速定位到可能包含该元素的桶，然后在桶内的链表或其它解决冲突的数据结构中查找目标元素。
3. **删除（Deletion）**：
   - 删除一个元素也具有平均O(1)的时间复杂度。找到包含目标元素的桶后，在桶内的数据结构中删除该元素即可。
4. **修改（Modification）**：
   - 由于`std::unordered_set`中的元素是不可变的，所以不能直接修改已存在的元素。若要更改元素值，必须先删除旧元素，再插入新元素，这样总的时间复杂度依然是O(1)平均情况下的两次操作。

然而，需要注意的是，这些操作的最坏时间复杂度可能是O(n)，尤其是在哈希表负载因子较高且哈希函数导致较多冲突的情况下。为了避免性能下降，标准库通常会动态调整哈希表大小以维持较低的负载因子，但这也意味着在某些情况下（例如大量元素的连续插入和删除），可能会发生重新哈希的操作，这将导致O(n)的时间开销。

