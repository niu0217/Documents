# unordered_multiset

## 1. 问题

### 1.1 C++中unordered_multiset和unordered_set的区别

`std::unordered_multiset`和`std::unordered_set`是C++标准库中基于哈希表实现的关联容器，它们的主要区别在于对键值重复的处理方式：

1. **键值唯一性**：
   - `std::unordered_set`：不允许键值重复。插入操作会自动排除重复键，即如果尝试插入一个已经存在的键，则不会插入新的元素，保持集合内每个键都是唯一的。
   - `std::unordered_multiset`：允许键值重复。即使键相同，也可以插入多个具有相同键的不同元素。
2. **查找、删除和计数**：
   - `std::unordered_set`：查找特定键时返回的是该键是否存在；删除操作会删除第一个匹配到的键及其对应的值；没有直接获取某个键出现次数的方法（因为总是最多只有一个）。
   - `std::unordered_multiset`：查找特定键时同样可以返回是否包含该键，但还可以通过迭代器遍历所有相同键的元素；删除操作可以选择删除所有匹配键的元素或者特定位置的一个实例；提供了`count(key)`方法来统计给定键在集合中出现的次数。
3. **应用场景**：
   - `std::unordered_set`适用于需要存储不重复键且不需要知道键重复次数的情况。
   - `std::unordered_multiset`适用于需要记录键出现次数或允许键值重复的情况下，例如统计单词在文档中的频率等场景。

两者都支持高效的O(1)平均时间复杂度的插入、查找和删除操作，但这些操作在最坏情况下可能会退化至O(n)，这取决于哈希函数的质量以及负载因子等因素。

## 2. 引入代码

```c++
#include <iostream>
#include <unordered_multiset>

int main() {
    // 创建一个无序多重集合，存储整数
    std::unordered_multiset<int> myMultiset;

    // 插入元素 (Insertion)
    myMultiset.insert(3);
    myMultiset.insert({5, 7, 9});  // 可以插入多个相同的元素
    myMultiset.insert(7);            // 同样可以插入已存在的元素

    // 查找元素 (Search)
    auto it = myMultiset.find(5);
    if (it != myMultiset.end()) {
        std::cout << "Found element: " << *it << '\n';
    } else {
        std::cout << "Element not found.\n";
    }

    // 计算元素数量 (Count)
    size_t count = myMultiset.count(7);
    std::cout << "Number of occurrences of 7: " << count << '\n';

    // 遍历所有元素 (Traversal)
    for (const auto& value : myMultiset) {
        std::cout << "Value: " << value << '\n';
    }

    // 删除单个元素 (Deletion - Single Element)
    it = myMultiset.find(3);
    if (it != myMultiset.end()) {
        myMultiset.erase(it);
    }

    // 删除所有匹配的元素 (Deletion - All Elements)
    myMultiset.erase(7);

    // 清空集合 (Clear)
    myMultiset.clear();

    return 0;
}
```

**注意**：

- `std::unordered_multiset`同样不支持通过索引访问元素。
- 虽然不能直接修改已存在元素的值，但可以通过删除并重新插入新值来实现“修改”。

其他函数还包括：

- `emplace(args)`：在集合中直接构造并插入元素。
- `erase(key)`：删除所有与给定键相等的元素（在`unordered_multiset`中可能有多个）。

## 3. 原理

`std::unordered_multiset`在C++标准库中的实现基于哈希表（Hash Table）。具体原理如下：

1. **哈希函数**：每个插入到`unordered_multiset`的元素都会通过一个哈希函数进行计算，将元素映射到一个哈希值。这个哈希值通常是一个整数，用于确定元素在哈希表中桶的位置。
2. **桶（Bucket）**：哈希表由一系列桶组成，每个桶内可以包含零个或多个元素。当两个元素映射到相同的哈希值时，就会发生哈希冲突。
3. **解决冲突**：为了处理哈希冲突，`std::unordered_multiset`通常采用链地址法（Separate Chaining），即为每个桶关联一个链表或者其他容器来存储所有哈希值相同但键值不同的元素。
4. **负载因子**：为了维持良好的性能，`std::unordered_multiset`会动态调整其内部哈希表的大小，以保持较低的负载因子（即元素数量与桶数量的比例）。当负载因子超过一定阈值时，容器会自动重新哈希所有元素到一个新的更大的哈希表中，从而降低冲突率。
5. **迭代器稳定性**：由于元素可能会因为哈希表的扩容而被重新排列和移动，因此在执行插入和删除操作后，除了指向被删除元素的迭代器外，其他迭代器可能失效。

综上所述，`std::unordered_multiset`利用哈希表技术实现了快速的增删查改操作，同时允许键值重复。其具体性能取决于哈希函数的质量、负载因子控制以及解决冲突的方法等。

## 4. 优点和缺点

**优点：**

1. **高效查找**：`std::unordered_multiset`基于哈希表实现，插入、删除和查找操作在平均情况下具有O(1)的时间复杂度。这意味着对于大量数据的增删查改操作，它能够提供快速响应。
2. **允许键重复**：与`std::unordered_set`不同，`std::unordered_multiset`允许存储多个相同的键（即键值可以重复），这对于需要统计每个元素出现次数的应用场景非常有用。
3. **空间效率**：尽管存在冲突时可能需要额外的空间来存储链表结构以解决哈希冲突，但在合理设计下，`std::unordered_multiset`仍能保持较好的空间效率。
4. **迭代器遍历**：虽然元素在物理存储上无序，但可以通过迭代器遍历集合内的所有元素。

**缺点：**

1. **哈希碰撞**：当哈希函数质量不高或输入数据分布不均导致过多哈希冲突时，查找、插入和删除的性能会退化至接近O(n)。尤其是在负载因子过高时，冲突增加可能导致性能显著降低。
2. **顺序不确定性**：`std::unordered_multiset`内部是无序的，无法保证元素的存储顺序，这在某些依赖元素顺序的场合可能会成为限制。
3. **迭代器失效**：插入和删除操作可能导致其他元素的位置发生变化，因此除了被删除元素的迭代器外，其他迭代器在这些操作后可能失效。
4. **初始化和重新哈希**：当容器需要扩容以降低负载因子时，需要对所有元素进行重新哈希并迁移至新的哈希表，这是一个耗时的过程，在大量元素的情况下尤其明显。
5. **空间浪费**：为了处理哈希冲突而预留的桶可能在低负载因子或者数据分布特别均匀的情况下造成一定的空间浪费。

## 5. 增删查改的效率

C++标准库中的`std::unordered_multiset`基于哈希表实现，其增删查改操作在理想情况下的时间复杂度期望为O(1)：

1. **插入（Insertion）**：
   - 插入一个元素时，首先通过哈希函数计算出元素应放入的桶的位置。若该位置上没有冲突或冲突较少，则插入操作可以快速完成，平均时间复杂度为O(1)。然而，如果桶内已经存在大量冲突，插入新元素会导致链表增长，这可能会增加插入的时间成本。
2. **查找（Search）**：
   - 查找特定元素同样先通过哈希函数定位到相应的桶，然后遍历桶内的元素以找到匹配项。在理想情况下，即使桶内存在冲突，但只要冲突数量不是太大，查找时间复杂度仍接近O(1)。
3. **删除（Deletion）**：
   - 删除元素时，也需要先找到目标元素所在的桶并从桶内关联的链表或其他数据结构中移除该元素。删除单个元素的操作也期望能在O(1)时间内完成。
4. **修改（Modification）**：
   - 对于`std::unordered_multiset`，由于元素是不可变的，所以不能直接修改元素值。如果要更改元素值，必须先删除旧元素，再插入新元素。这样总的操作时间复杂度通常表现为两次操作的叠加，即O(1 + 1) = O(1)。

需要注意的是，在最坏情况下，当哈希函数质量不高导致哈希碰撞过多，或者负载因子过高时，上述操作的实际性能可能退化至O(n)，其中n表示容器中元素的数量。为了避免这种情况，标准库会动态调整容器大小以保持较低的负载因子，并尽量减少冲突。