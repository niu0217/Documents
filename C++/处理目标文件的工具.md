# 处理目标文件的工具

## 1. 问题

## 2. 工具概述

在Linux中，处理目标文件（也称为对象文件）的常用工具包括：

1. **objdump**：这是一个用于查看目标文件信息的工具，可以显示文件的内容、符号表、重定位条目等。

   示例：

   - 查看文件头部信息：`objdump -f file.o`
   - 显示符号表：`objdump -t file.o`

2. **readelf**：这是一个用于查看ELF格式的目标文件和可执行文件的工具，提供了详细的信息，包括文件头、段信息、符号表等。 

   示例：

   - 查看文件头部信息：`readelf -h file.o`
   - 显示节区信息：`readelf -S file.o`
   - 显示符号表：`readelf -s file.o`

3. **nm**：这是一个用于列出目标文件符号的工具，包括函数名、全局变量和其他定义的符号。

   示例：

   - 列出所有符号：`nm file.o`
   - 只列出外部符号：`nm -g file.o`

4. **ld**：这是一个链接器，用于将一个或多个目标文件和库文件链接成一个可执行文件或动态库。

   示例：

   - 链接目标文件和库生成可执行文件：`ld -o myprog file1.o file2.o -L/path/to/library -lmylib`
   - 创建动态库：`ld -shared -o libmylib.so file1.o file2.o`

5. **gcc/g++**：虽然主要是编译器，但它们也可以用来链接目标文件。通常情况下，我们会用它们来编译和链接源代码，但也可以直接用来链接目标文件。 

   示例：

   - 链接目标文件生成可执行文件：`gcc -o myprog file1.o file2.o`

6. **objcopy**：这是一个用于复制和修改目标文件内容的工具，可以用来创建或修改二进制文件、从一个文件格式转换到另一个文件格式等。

   示例：

   - 从ELF格式转换为纯二进制格式：`objcopy -O binary file.o file.bin`

这些工具可以帮助你理解和操作目标文件的各种属性和内容，以便进行调试、优化或者解决链接问题。

## 3. 工具具体说明

### 3.1 objdump

`objdump` 是一个在 Linux 和 Unix 系统中广泛使用的工具，用于查看目标文件（包括可执行文件、对象文件和库文件）的详细信息。以下是一些常用的 `objdump` 使用方法和例子：

1. **查看文件头部信息**：

   ```bash
   objdump -f file.o
   ```

   这将显示文件类型、机器类型、版本、入口点等信息。

2. **反汇编代码**：

   ```bash
   objdump -d file.o
   ```

   这将反汇编文件中的所有代码段，并显示原始的汇编指令。

3. **查看特定地址范围的反汇编代码**：

   ```bash
   objdump -d --start-address=0x1000 --stop-address=0x2000 file.o
   ```

   这将只反汇编从地址 0x1000 到 0x2000 的代码段。

4. **查看符号表**：

   ```bash
   objdump -t file.o
   ```

   这将显示文件中的符号表，包括符号名称、值、类型和绑定信息。

5. **查看重定位条目**：

   ```bash
   objdump -r file.o
   ```

   这将显示文件中的重定位条目，这些条目指示了链接器如何修改二进制文件中的地址。

6. **以十六进制格式查看文件内容**：

   ```bash
   objdump -x file.o
   ```

   这将显示文件的所有部分，包括头部、节区、符号表和重定位条目，以十六进制格式表示。

7. **查看特定节区的内容**：

   ```bash
   objdump -s -j .text file.oc
   ```

   这将显示 `.text` 节区的内容，包括其十六进制表示和ASCII表示。

8. **查看ELF文件头部信息**：

   ```bash
   objdump -h file.o
   ```

   这将显示 ELF 文件的头部信息，包括各个节区的名称、类型、大小和偏移量。

9. **以C源代码格式查看反汇编代码**：

   ```bash
   objdump -S file.o
   ```

   这将同时显示源代码和对应的汇编代码，便于理解源代码与生成的机器码之间的关系。

以上是一些基本的 `objdump` 使用方法和例子。根据需要，你还可以组合使用不同的选项来获取更详细的信息。例如，你可以使用 `-M` 选项指定不同的架构或指令集，或者使用 `-l` 选项显示符号在动态符号表中的索引等。

### 3.2 readelf

`readelf` 是一个用于查看 ELF（Executable and Linkable Format）格式的目标文件、可执行文件和库文件的详细信息的工具。以下是一些常用的 `readelf` 使用方法和例子：

1. **查看文件头部信息**：

   ```bash
   readelf -h file.o
   ```

   这将显示文件的基本头部信息，包括类型、机器类型、版本、入口点等。

2. **查看程序头表**：

   ```bash
   readelf -l file.o
   ```

   这将显示程序头表（Program Header Table），包含关于如何创建进程映像的信息，如段的加载地址、大小和权限等。

3. **查看节区头部表**：

   ```bash
   readelf -S file.o
   ```

   这将显示节区头部表（Section Header Table），包含每个节区的名称、类型、大小、偏移量和权限等信息。

4. **查看特定节区的内容**：

   ```bash
   readelf -x .text file.o
   ```

   这将以十六进制格式显示 `.text` 节区的内容。

5. **查看符号表**：

   ```bash
   readelf -s file.o
   ```

   这将显示文件的符号表，包括符号名称、值、大小、类型和绑定信息。

6. **查看重定位条目**：

   ```bash
   readelf -r file.o
   ```

   这将显示文件中的重定位条目，这些条目指示了链接器如何修改二进制文件中的地址。

7. **查看动态段信息**：

   ```bash
   readelf -d file.o
   ```

   这将显示文件的动态段信息，包括动态链接器需要解析的动态符号、共享对象依赖项和其他动态链接相关信息。

8. **查看文件的版本信息**：

   ```bash
   readelf --version-info file.o
   ```

   这将显示文件的版本信息，如果文件包含了版本段的话。

以上是一些基本的 `readelf` 使用方法和例子。根据需要，你还可以组合使用不同的选项来获取更详细的信息。例如，你可以使用 `-w` 选项来忽略某些警告，或者使用 `--debug-dump=decodedline` 来查看源代码与机器码之间的行号对应关系等。

### 3.3 nm

`nm` 是一个在 Linux 和 Unix 系统中用于查看目标文件（包括可执行文件、对象文件和库文件）符号表的工具。以下是一些常用的 `nm` 使用方法和例子：

1. **列出所有符号**：

   ```bash
   nm file.o
   ```

   这将列出文件中的所有符号，包括函数名、全局变量和其他定义的符号。

2. **按类型过滤符号**：

   ```bash
   nm -type file.o
   ```

   其中 `type` 可以是以下类型之一：

   - `a`: 仅显示绝对符号（Absolute symbols）
   - `b`: 仅显示 bss 符号（Uninitialized data symbols）
   - `d`: 仅显示数据符号（Initialized data symbols）
   - `g`: 仅显示外部全局符号（Global symbols）
   - `l`: 仅显示局部符号（Local symbols）
   - `n`: 按名称排序符号
   - `p`: 仅显示小写符号
   - `r`: 仅显示只读符号
   - `s`: 仅显示文本段符号（Code symbols）
   - `u`: 仅显示未定义的符号
   - `w`: 仅显示弱定义的符号

3. **显示符号地址和大小**：

   ```bash
   nm -n file.o
   ```

   这将显示每个符号的地址和大小。

4. **显示符号在哪个源文件中定义**：

   ```bash
   nm -A file.o
   ```

   如果编译时启用了调试信息，这将显示每个符号所在的源文件。

5. **按照符号值排序**：

   ```bash
   nm -v file.o
   ```

   这将按照符号的值进行排序。

6. **查看动态符号**：

   ```bash
   nm -D file.o
   ```

   这将显示动态符号，这些符号通常用于动态链接。

以下是一些具体的例子：

- 列出所有全局符号：

  ```bash
  nm -g file.o
  ```

- 列出所有未定义的符号：

  ```bash
  nm -u file.o
  ```

- 显示符号地址和大小，并按照符号值排序：

  ```bash
  nm -nv file.o
  ```

- 查看动态符号并显示符号所在的源文件（如果可用）：

  ```bash
  nm -AD file.o
  ```

以上是一些基本的 `nm` 使用方法和例子。根据需要，你还可以组合使用不同的选项来获取更详细的信息。例如，你可以使用 `-P` 选项来禁用默认的符号解析，或者使用 `--defined-only` 选项来仅显示已定义的符号等。

### 3.4 ld

`ld` 是一个在 Linux 和 Unix 系统中用于链接目标文件（包括可执行文件、对象文件和库文件）的工具。以下是一些常用的 `ld` 使用方法和例子：

1. **基本链接**：

   ```bash
   ld -o output_file object_file1.o object_file2.o
   ```

   这将链接指定的对象文件，并生成名为 `output_file` 的可执行文件。

2. **链接静态库**：

   ```bash
   ld -o output_file object_file1.o object_file2.o -L/path/to/library -lmylib
   ```

   这将在链接过程中查找路径 `/path/to/library` 下的 `libmylib.a` 静态库，并将其包含在输出文件中。

3. **链接动态库**：

   ```bash
   ld -shared -o libmylib.so object_file1.o object_file2.o
   ```

   这将创建一个名为 `libmylib.so` 的共享库，该库包含了指定的对象文件。

4. **指定入口点**：

   ```bash
   ld -o output_file --entry=start symbol object_file1.o object_file2.o
   ```

   这将指定 `start` 符号作为程序的入口点。

5. **添加符号**：

   ```bash
   ld -o output_file --defsym=symbol=value object_file1.o object_file2.o
   ```

   这将在链接过程中添加一个名为 `symbol` 的符号，其值为 `value`。

6. **忽略未解析的符号**：

   ```bash
   ld -o output_file --allow-shlib-undefined object_file1.o object_file2.o
   ```

   这将允许链接器生成一个含有未解析符号的可执行文件或共享库。

7. **设置链接器脚本**：

   ```bash
   ld -o output_file -T link_script.ld object_file1.o object_file2.o
   ```

   这将使用指定的链接器脚本 `link_script.ld` 来控制链接过程。

以下是一些具体的例子：

- 链接两个对象文件并生成可执行文件：

  ```bash
  ld -o my_program file1.o file2.o
  ```

- 链接对象文件和静态库，并指定搜索路径：

  ```bash
  ld -o my_program file1.o file2.o -L/usr/local/lib -lmylib
  ```

- 创建一个共享库并指定 soname：

  ```bash
  ld -shared -o libmylib.so.1.0 -soname libmylib.so.1 file1.o file2.o
  ```

- 指定链接器脚本并链接对象文件：

  ```bash
  ld -o my_program -T link_script.ld file1.o file2.o
  ```

以上是一些基本的 `ld` 使用方法和例子。根据需要，你还可以组合使用不同的选项来定制链接过程。例如，你可以使用 `-r` 选项来生成 relocatable 文件，或者使用 `-z` 选项来控制 ELF 特性等。在实际使用中，通常会通过 GCC 或其他编译器驱动程序来调用 `ld`，因为它们会自动处理许多细节并提供更高级的功能。

### 3.5 gcc

`gcc` 是一个在 Linux 和 Unix 系统中广泛使用的编译器，主要用于编译 C、C++、Objective-C 和 Objective-C++ 等语言的源代码。以下是一些常用的 `gcc` 使用方法和例子：

1. **基本编译**：

   ```bash
   gcc source_file.c -o output_file
   ```

   这将编译指定的源文件，并生成名为 `output_file` 的可执行文件。

2. **编译多个源文件**：

   ```bash
   gcc source_file1.c source_file2.c -o output_file
   ```

   这将编译多个源文件，并生成一个可执行文件。

3. **编译并链接静态库**：

   ```bash
   gcc source_file.c -o output_file -L/path/to/library -lmylib
   ```

   这将在编译和链接过程中查找路径 `/path/to/library` 下的 `libmylib.a` 静态库，并将其包含在输出文件中。

4. **编译并链接动态库**：

   ```bash
   gcc -shared -o libmylib.so source_file.c
   ```

   这将创建一个名为 `libmylib.so` 的共享库，该库包含了指定的源文件。

5. **启用警告**：

   ```bash
   gcc -Wall source_file.c -o output_file
   ```

   这将启用所有常用警告。

6. **优化编译**：

   ```bash
   gcc -O2 source_file.c -o output_file
   ```

   这将使用级别为2的优化进行编译。

7. **指定包含目录**：

   ```bash
   gcc -I/include/path source_file.c -o output_file
   ```

   这将添加 `/include/path` 到头文件搜索路径。

8. **预处理源代码**：

   ```bash
   gcc -E source_file.c -o preprocessed_file.i
   ```

   这将执行预处理步骤并将结果输出到 `preprocessed_file.i` 文件。

9. **生成汇编代码**：

   ```bash
   gcc -S source_file.c -o assembly_file.s
   ```

   这将生成汇编代码并保存到 `assembly_file.s` 文件。

以下是一些具体的例子：

- 编译一个简单的 C 程序：

  ```bash
  gcc hello_world.c -o hello_world
  ```

- 编译并链接一个使用静态库的程序：

  ```bash
  gcc main.c -o my_program -L./lib -lmylib
  ```

- 启用所有警告并优化编译：

  ```bash
  gcc -Wall -O2 my_source.c -o my_program
  ```

- 指定包含目录并编译：

  ```bash
  gcc -I/usr/local/include my_source.c -o my_program
  ```

- 预处理源代码：

  ```bash
  gcc -E my_source.c -o preprocessed_my_source.i
  ```

以上是一些基本的 `gcc` 使用方法和例子。根据需要，你还可以组合使用不同的选项来定制编译过程。例如，你可以使用 `-std` 选项来指定语言标准，或者使用 `-f` 选项来控制编译器的行为等。在实际使用中，通常会通过 Makefile 或其他构建工具来调用 `gcc`，因为它们可以自动化编译和链接过程并处理更复杂的依赖关系。

### 3.6 objcopy

`objcopy` 是一个在 Linux 和 Unix 系统中用于复制和修改目标文件（包括可执行文件、对象文件和库文件）的工具。以下是一些常用的 `objcopy` 使用方法和例子：

1. **复制目标文件**：

   ```bash
   objcopy --binary-architecture=<arch> input_file output_file
   ```

   这将复制输入文件到输出文件。`<arch>` 参数用于指定目标架构。

2. **创建二进制文件**：

   ```bash
   objcopy -O binary input_file output_file
   ```

   这将从输入文件创建一个纯二进制文件。

3. **从 ELF 文件中提取节区**：

   ```bash
   objcopy --only-section=<section_name> input_file output_file
   ```

   这将从输入文件中提取指定的节区并保存到输出文件。

4. **添加或替换节区**：

   ```bash
   objcopy --add-section <section_name>=<file> input_file output_file
   ```

   或

   ```bash
   objcopy --replace-section <section_name>=<file> input_file output_file
   ```

   这将从 `<file>` 中添加或替换输入文件中的指定节区，并保存到输出文件。

5. **更改文件类型**：

   ```bash
   objcopy -O <output_format> input_file output_file
   ```

   这将更改输入文件的格式为指定的输出格式。

6. **删除符号**：

   ```bash
   objcopy --remove-symbol=<symbol_name> input_file output_file
   ```

   这将在输出文件中删除指定的符号。

以下是一些具体的例子：

- 从 ELF 文件创建二进制文件：

  ```bash
  objcopy -O binary my_elf_file my_binary_file
  ```

- 提取 `.text` 节区到单独的文件：

  ```bash
  objcopy --only-section=.text my_elf_file text_section.bin
  ```

- 向 ELF 文件中添加一个新的节区：

  ```bash
  objcopy --add-section .my_new_section=my_new_data.txt my_elf_file modified_elf_file
  ```

- 将 ELF 文件转换为 COFF 格式：

  ```bash
  objcopy -O coff my_elf_file my_coff_file
  ```

- 从 ELF 文件中删除名为 `my_function` 的符号：

  ```bash
  objcopy --remove-symbol=my_function my_elf_file modified_elf_file
  ```

以上是一些基本的 `objcopy` 使用方法和例子。根据需要，你还可以组合使用不同的选项来定制复制和修改过程。例如，你可以使用 `-R` 选项来排除特定节区，或者使用 `--redefine-sym` 选项来重命名符号等。在实际使用中，`objcopy` 常用于创建 bootloaders、固件映像、内核模块等特殊用途的目标文件。

### 3.7 ldd

`ldd` 是一个在 Linux 和 Unix 系统中用于查看可执行文件或共享库的动态链接依赖关系的工具。以下是一些常用的 `ldd` 使用方法和例子：

1. **查看可执行文件的依赖关系**：

   ```bash
   ldd executable_file
   ```

   这将显示 `executable_file` 的所有动态链接依赖项，包括库文件及其路径。

2. **查看特定版本的库文件**：

   ```bash
   ldd --version-info executable_file
   ```

   这将显示 `executable_file` 所依赖的库文件的版本信息。

3. **使用伪链接器**：

   ```bash
   ldd --library-rpath=path/to/library executable_file
   ```

   这将使用指定的库路径来解析依赖关系，而不是系统默认的库路径。

4. **静默运行**：

   ```bash
   ldd --silent executable_file
   ```

   这将只显示无法找到的依赖项，而不显示所有已解析的依赖项。

以下是一些具体的例子：

- 查看 `my_program` 可执行文件的依赖关系：

  ```bash
  ldd my_program
  ```

- 查看 `my_library.so` 共享库的依赖关系：

  ```bash
  ldd ./libmy_library.so
  ```

- 使用特定路径解析 `my_program` 的依赖关系：

  ```bash
  ldd --library-rpath=/opt/mylibs my_program
  ```

- 只显示 `my_program` 中未找到的依赖项：

  ```bash
  ldd --silent my_program
  ```

以上是一些基本的 `ldd` 使用方法和例子。请注意，`ldd` 并不会实际加载或运行程序，它只是解析可执行文件的动态链接信息。在某些情况下，`ldd` 可能无法准确反映运行时的库加载情况，例如当使用运行时符号解析或者库文件路径被修改时。在实际使用中，`ldd` 常用于调试动态链接问题、检查库版本兼容性等。

## 4. 实战的代码

### 文件结构

```
include/
└── my_vector.h
dynamic_library/
├── addvec.c
├── addvec.o
├── libvector.so
├── makefile
├── multvec.c
└── multvec.o
test_dynamic_library/
├── main
├── main.c
├── main.o
└── makefile
```

### include

```c
//my_vector.h

#include<stdlib.h>
#include<stdio.h>

void addvec(int *x, int *y, int *z, int n);
void multvec(int *x,int *y, int *z, int n);
```

### dynamic_library

```c
//addvec.c

#include "../include/my_vector.h"

int add_cnt = 0;

void addvec(int *x, int *y, int *z, int n) {
    int i;
    add_cnt++;
    for(i = 0; i < n; i++) {
        z[i] = x[i] + y[i];
    }
}
```

```c
//multvec.c

#include "../include/my_vector.h"

int mult_cnt = 0;

void multvec(int *x,int *y, int *z, int n) {
    int i;
    mult_cnt++;
    for(i = 0; i < n; i++) {
        z[i] = x[i] + y[i];
    }
}
```

```makefile
# makefile

# 定义所需的C编译器和链接器
CC = gcc
LD = $(CC)

# 定义源文件和目标文件
SOURCES = multvec.c addvec.c
OBJECTS = $(SOURCES:.c=.o)
OUTPUT = libvector.so

# 定义CFLAGS LDFLAGS HEAD_FLAGS
CFLAGS = -fPIC -Wall -Wextra -g
LDFLAGS = -shared
HFLAGS = -I../include  #指定需要包含的头文件路径


# 默认目标
all: $(OUTPUT)

# 编译目标对象文件
%.o: %.c my_vector.h
	$(CC) $(CFLAGS) $(HFLAGS) -c $< -o $@

# 链接目标动态库
$(OUTPUT): $(OBJECTS)
	$(LD) $(LDFLAGS) -o $@ $^

# 清理目标文件和生成的动态库
clean:
	rm $(OBJECTS) $(OUTPUT)
```

### test_dynamic_library

```c++
//main.c

#include<stdio.h>
#include "../include/my_vector.h"

int x[2] = {1, 2};
int y[2] = {3, 4};
int z[2];

int main()
{
    addvec(x, y, z, 2);
    printf("z = [%d %d]\n", z[0], z[1]);
    return 0;
}
```

```makefile
# makefile
# 定义所需的C编译器和链接器
CC = gcc
LD = $(CC)

# 定义源文件和目标文件
SOURCES = main.c
OBJECTS = $(SOURCES:.c=.o)
EXECUTABLE = main

# 定义CFLAGS LDFLAGS HEAD_FLAGS
CFLAGS = -Wall -g
LDFLAGS = -L../dynamic_library -lvector
HFLAGS = -I../include

# 默认目标
all: $(EXECUTABLE)

# 编译目标对象文件
%.o: %.c
	$(CC) $(CFLAGS) $(HFLAGS) -c $< -o $@

# 链接目标可执行文件
$(EXECUTABLE): $(OBJECTS)
	$(LD) -o $@ $^ $(LDFLAGS)

# 清理目标文件和生成的可执行文件
clean:
	rm $(OBJECTS) $(EXECUTABLE)
```

## 5. 实战

### 5.1 objdump

```bash
# 查看文件头部信息
ubuntu@niu0217:~/Dev/MyLib/dynamic_library$ objdump -f addvec.o

addvec.o:     file format elf64-x86-64
architecture: i386:x86-64, flags 0x00000011:
HAS_RELOC, HAS_SYMS
start address 0x0000000000000000

ubuntu@niu0217:~/Dev/MyLib/dynamic_library$
```

```bash
# 反汇编代码
ubuntu@niu0217:~/Dev/MyLib/dynamic_library$ objdump -d addvec.o

addvec.o:     file format elf64-x86-64


Disassembly of section .text:

0000000000000000 <addvec>:
   0:	f3 0f 1e fa          	endbr64
   4:	55                   	push   %rbp
   5:	48 89 e5             	mov    %rsp,%rbp
   8:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
   c:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  10:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  14:	89 4d d4             	mov    %ecx,-0x2c(%rbp)
  17:	48 8b 05 00 00 00 00 	mov    0x0(%rip),%rax        # 1e <addvec+0x1e>
  1e:	8b 00                	mov    (%rax),%eax
  20:	8d 50 01             	lea    0x1(%rax),%edx
  23:	48 8b 05 00 00 00 00 	mov    0x0(%rip),%rax        # 2a <addvec+0x2a>
  2a:	89 10                	mov    %edx,(%rax)
  2c:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  33:	eb 48                	jmp    7d <addvec+0x7d>
  35:	8b 45 fc             	mov    -0x4(%rbp),%eax
  38:	48 98                	cltq
  3a:	48 8d 14 85 00 00 00 	lea    0x0(,%rax,4),%rdx
  41:	00
  42:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  46:	48 01 d0             	add    %rdx,%rax
  49:	8b 08                	mov    (%rax),%ecx
  4b:	8b 45 fc             	mov    -0x4(%rbp),%eax
  4e:	48 98                	cltq
  50:	48 8d 14 85 00 00 00 	lea    0x0(,%rax,4),%rdx
  57:	00
  58:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  5c:	48 01 d0             	add    %rdx,%rax
  5f:	8b 10                	mov    (%rax),%edx
  61:	8b 45 fc             	mov    -0x4(%rbp),%eax
  64:	48 98                	cltq
  66:	48 8d 34 85 00 00 00 	lea    0x0(,%rax,4),%rsi
  6d:	00
  6e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  72:	48 01 f0             	add    %rsi,%rax
  75:	01 ca                	add    %ecx,%edx
  77:	89 10                	mov    %edx,(%rax)
  79:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  7d:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80:	3b 45 d4             	cmp    -0x2c(%rbp),%eax
  83:	7c b0                	jl     35 <addvec+0x35>
  85:	90                   	nop
  86:	90                   	nop
  87:	5d                   	pop    %rbp
  88:	c3                   	retq
ubuntu@niu0217:~/Dev/MyLib/dynamic_library$
```

```bash
# 以C源代码格式查看反汇编代码
ubuntu@niu0217:~/Dev/MyLib/dynamic_library$ objdump -S addvec.o

addvec.o:     file format elf64-x86-64


Disassembly of section .text:

0000000000000000 <addvec>:
#include "../include/my_vector.h"

int add_cnt = 0;

void addvec(int *x, int *y, int *z, int n) {
   0:	f3 0f 1e fa          	endbr64
   4:	55                   	push   %rbp
   5:	48 89 e5             	mov    %rsp,%rbp
   8:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
   c:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  10:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  14:	89 4d d4             	mov    %ecx,-0x2c(%rbp)
    int i;
    add_cnt++;
  17:	48 8b 05 00 00 00 00 	mov    0x0(%rip),%rax        # 1e <addvec+0x1e>
  1e:	8b 00                	mov    (%rax),%eax
  20:	8d 50 01             	lea    0x1(%rax),%edx
  23:	48 8b 05 00 00 00 00 	mov    0x0(%rip),%rax        # 2a <addvec+0x2a>
  2a:	89 10                	mov    %edx,(%rax)
    for(i = 0; i < n; i++) {
  2c:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  33:	eb 48                	jmp    7d <addvec+0x7d>
        z[i] = x[i] + y[i];
  35:	8b 45 fc             	mov    -0x4(%rbp),%eax
  38:	48 98                	cltq
  3a:	48 8d 14 85 00 00 00 	lea    0x0(,%rax,4),%rdx
  41:	00
  42:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  46:	48 01 d0             	add    %rdx,%rax
  49:	8b 08                	mov    (%rax),%ecx
  4b:	8b 45 fc             	mov    -0x4(%rbp),%eax
  4e:	48 98                	cltq
  50:	48 8d 14 85 00 00 00 	lea    0x0(,%rax,4),%rdx
  57:	00
  58:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  5c:	48 01 d0             	add    %rdx,%rax
  5f:	8b 10                	mov    (%rax),%edx
  61:	8b 45 fc             	mov    -0x4(%rbp),%eax
  64:	48 98                	cltq
  66:	48 8d 34 85 00 00 00 	lea    0x0(,%rax,4),%rsi
  6d:	00
  6e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  72:	48 01 f0             	add    %rsi,%rax
  75:	01 ca                	add    %ecx,%edx
  77:	89 10                	mov    %edx,(%rax)
    for(i = 0; i < n; i++) {
  79:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  7d:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80:	3b 45 d4             	cmp    -0x2c(%rbp),%eax
  83:	7c b0                	jl     35 <addvec+0x35>
    }
}
  85:	90                   	nop
  86:	90                   	nop
  87:	5d                   	pop    %rbp
  88:	c3                   	retq
ubuntu@niu0217:~/Dev/MyLib/dynamic_library$
```

```bash
# 查看符号表
ubuntu@niu0217:~/Dev/MyLib/dynamic_library$ objdump -t addvec.o

addvec.o:     file format elf64-x86-64

SYMBOL TABLE:
0000000000000000 l    df *ABS*	0000000000000000 addvec.c
0000000000000000 l    d  .text	0000000000000000 .text
0000000000000000 l    d  .data	0000000000000000 .data
0000000000000000 l    d  .bss	0000000000000000 .bss
0000000000000000 l    d  .debug_info	0000000000000000 .debug_info
0000000000000000 l    d  .debug_abbrev	0000000000000000 .debug_abbrev
0000000000000000 l    d  .debug_aranges	0000000000000000 .debug_aranges
0000000000000000 l    d  .debug_line	0000000000000000 .debug_line
0000000000000000 l    d  .debug_str	0000000000000000 .debug_str
0000000000000000 l    d  .note.GNU-stack	0000000000000000 .note.GNU-stack
0000000000000000 l    d  .note.gnu.property	0000000000000000 .note.gnu.property
0000000000000000 l    d  .eh_frame	0000000000000000 .eh_frame
0000000000000000 l    d  .comment	0000000000000000 .comment
0000000000000000 g     O .bss	0000000000000004 add_cnt
0000000000000000 g     F .text	0000000000000089 addvec
0000000000000000         *UND*	0000000000000000 _GLOBAL_OFFSET_TABLE_


ubuntu@niu0217:~/Dev/MyLib/dynamic_library$
```

```bash
# 查看重定位条目
ubuntu@niu0217:~/Dev/MyLib/dynamic_library$ objdump -r addvec.o

addvec.o:     file format elf64-x86-64

RELOCATION RECORDS FOR [.text]:
OFFSET           TYPE              VALUE
000000000000001a R_X86_64_REX_GOTPCRELX  add_cnt-0x0000000000000004
0000000000000026 R_X86_64_REX_GOTPCRELX  add_cnt-0x0000000000000004


RELOCATION RECORDS FOR [.debug_info]:
OFFSET           TYPE              VALUE
0000000000000006 R_X86_64_32       .debug_abbrev
000000000000000c R_X86_64_32       .debug_str+0x000000000000020a
0000000000000011 R_X86_64_32       .debug_str+0x00000000000001b2
0000000000000015 R_X86_64_32       .debug_str+0x0000000000000169
0000000000000019 R_X86_64_64       .text
0000000000000029 R_X86_64_32       .debug_line
000000000000002e R_X86_64_32       .debug_str+0x000000000000001c
000000000000003c R_X86_64_32       .debug_str+0x0000000000000104
000000000000004a R_X86_64_32       .debug_str+0x00000000000000ea
0000000000000051 R_X86_64_32       .debug_str+0x0000000000000089
0000000000000058 R_X86_64_32       .debug_str+0x000000000000005a
000000000000005f R_X86_64_32       .debug_str+0x00000000000001d0
0000000000000066 R_X86_64_32       .debug_str+0x000000000000012d
000000000000006d R_X86_64_32       .debug_str+0x0000000000000068
0000000000000074 R_X86_64_32       .debug_str+0x00000000000001de
0000000000000079 R_X86_64_32       .debug_str
0000000000000085 R_X86_64_32       .debug_str+0x00000000000002a2
000000000000009b R_X86_64_32       .debug_str+0x000000000000029d
00000000000000a7 R_X86_64_32       .debug_str+0x000000000000003a
00000000000000ac R_X86_64_32       .debug_str+0x00000000000001a9
00000000000000b9 R_X86_64_32       .debug_str+0x0000000000000092
00000000000000c6 R_X86_64_32       .debug_str+0x0000000000000008
00000000000000d3 R_X86_64_32       .debug_str+0x000000000000007c
00000000000000e0 R_X86_64_32       .debug_str+0x00000000000002ac
00000000000000ed R_X86_64_32       .debug_str+0x0000000000000307
00000000000000fa R_X86_64_32       .debug_str+0x0000000000000116
0000000000000107 R_X86_64_32       .debug_str+0x0000000000000190
0000000000000114 R_X86_64_32       .debug_str+0x000000000000002d
0000000000000121 R_X86_64_32       .debug_str+0x0000000000000099
000000000000012e R_X86_64_32       .debug_str+0x0000000000000140
000000000000013b R_X86_64_32       .debug_str+0x00000000000002de
0000000000000148 R_X86_64_32       .debug_str+0x00000000000002ba
0000000000000155 R_X86_64_32       .debug_str+0x00000000000001c7
0000000000000162 R_X86_64_32       .debug_str+0x0000000000000015
000000000000016f R_X86_64_32       .debug_str+0x0000000000000074
000000000000017c R_X86_64_32       .debug_str+0x0000000000000154
0000000000000189 R_X86_64_32       .debug_str+0x00000000000000bd
0000000000000196 R_X86_64_32       .debug_str+0x00000000000000a5
00000000000001a3 R_X86_64_32       .debug_str+0x00000000000001f6
00000000000001b0 R_X86_64_32       .debug_str+0x0000000000000023
00000000000001bd R_X86_64_32       .debug_str+0x000000000000014e
00000000000001ca R_X86_64_32       .debug_str+0x00000000000000c9
00000000000001d7 R_X86_64_32       .debug_str+0x0000000000000051
00000000000001e4 R_X86_64_32       .debug_str+0x00000000000002fc
00000000000001f1 R_X86_64_32       .debug_str+0x00000000000002ee
00000000000001fe R_X86_64_32       .debug_str+0x00000000000000f7
000000000000020b R_X86_64_32       .debug_str+0x00000000000002c7
0000000000000218 R_X86_64_32       .debug_str+0x000000000000015c
0000000000000225 R_X86_64_32       .debug_str+0x00000000000002ce
0000000000000233 R_X86_64_32       .debug_str+0x0000000000000205
000000000000023f R_X86_64_32       .debug_str+0x000000000000019e
0000000000000247 R_X86_64_32       .debug_str+0x00000000000000d9
000000000000026e R_X86_64_32       .debug_str+0x00000000000000b1
0000000000000279 R_X86_64_32       .debug_str+0x00000000000001e8
0000000000000294 R_X86_64_32       .debug_str+0x00000000000000e4
00000000000002a6 R_X86_64_32       .debug_str+0x0000000000000162
00000000000002b2 R_X86_64_32       .debug_str+0x00000000000002d7
00000000000002be R_X86_64_32       .debug_str+0x0000000000000124
00000000000002e5 R_X86_64_32       .debug_str+0x00000000000001bb
00000000000002f1 R_X86_64_32       .debug_str+0x00000000000000d1
00000000000002fe R_X86_64_64       add_cnt
0000000000000307 R_X86_64_32       .debug_str+0x0000000000000316
000000000000030e R_X86_64_64       .text


RELOCATION RECORDS FOR [.debug_aranges]:
OFFSET           TYPE              VALUE
0000000000000006 R_X86_64_32       .debug_info
0000000000000010 R_X86_64_64       .text


RELOCATION RECORDS FOR [.debug_line]:
OFFSET           TYPE              VALUE
00000000000000fd R_X86_64_64       .text


RELOCATION RECORDS FOR [.eh_frame]:
OFFSET           TYPE              VALUE
0000000000000020 R_X86_64_PC32     .text


ubuntu@niu0217:~/Dev/MyLib/dynamic_library$
```

```bash
# 查看特定节区的内容
ubuntu@niu0217:~/Dev/MyLib/dynamic_library$ objdump -s -j .text addvec.o

addvec.o:     file format elf64-x86-64

Contents of section .text:
 0000 f30f1efa 554889e5 48897de8 488975e0  ....UH..H.}.H.u.
 0010 488955d8 894dd448 8b050000 00008b00  H.U..M.H........
 0020 8d500148 8b050000 00008910 c745fc00  .P.H.........E..
 0030 000000eb 488b45fc 4898488d 14850000  ....H.E.H.H.....
 0040 0000488b 45e84801 d08b088b 45fc4898  ..H.E.H.....E.H.
 0050 488d1485 00000000 488b45e0 4801d08b  H.......H.E.H...
 0060 108b45fc 4898488d 34850000 0000488b  ..E.H.H.4.....H.
 0070 45d84801 f001ca89 108345fc 018b45fc  E.H.......E...E.
 0080 3b45d47c b090905d c3                 ;E.|...].
ubuntu@niu0217:~/Dev/MyLib/dynamic_library$
```

```bash
# 查看ELF文件头部信息
ubuntu@niu0217:~/Dev/MyLib/dynamic_library$ objdump -h addvec.o

addvec.o:     file format elf64-x86-64

Sections:
Idx Name          Size      VMA               LMA               File off  Algn
  0 .text         00000089  0000000000000000  0000000000000000  00000040  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  0000000000000000  0000000000000000  000000c9  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000004  0000000000000000  0000000000000000  000000cc  2**2
                  ALLOC
  3 .debug_info   0000036d  0000000000000000  0000000000000000  000000cc  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING, OCTETS
  4 .debug_abbrev 00000103  0000000000000000  0000000000000000  00000439  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
  5 .debug_aranges 00000030  0000000000000000  0000000000000000  0000053c  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING, OCTETS
  6 .debug_line   0000014d  0000000000000000  0000000000000000  0000056c  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING, OCTETS
  7 .debug_str    0000031d  0000000000000000  0000000000000000  000006b9  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
  8 .comment      0000002c  0000000000000000  0000000000000000  000009d6  2**0
                  CONTENTS, READONLY
  9 .note.GNU-stack 00000000  0000000000000000  0000000000000000  00000a02  2**0
                  CONTENTS, READONLY
 10 .note.gnu.property 00000020  0000000000000000  0000000000000000  00000a08  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
 11 .eh_frame     00000038  0000000000000000  0000000000000000  00000a28  2**3
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA
ubuntu@niu0217:~/Dev/MyLib/dynamic_library$
```

### 5.2 readelf

```bash
# 查看文件头部信息
ubuntu@niu0217:~/Dev/MyLib/dynamic_library$ readelf -h addvec.o
ELF Header:
  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00
  Class:                             ELF64
  Data:                              2's complement, little endian
  Version:                           1 (current)
  OS/ABI:                            UNIX - System V
  ABI Version:                       0
  Type:                              REL (Relocatable file)
  Machine:                           Advanced Micro Devices X86-64
  Version:                           0x1
  Entry point address:               0x0
  Start of program headers:          0 (bytes into file)
  Start of section headers:          4960 (bytes into file)
  Flags:                             0x0
  Size of this header:               64 (bytes)
  Size of program headers:           0 (bytes)
  Number of program headers:         0
  Size of section headers:           64 (bytes)
  Number of section headers:         21
  Section header string table index: 20
ubuntu@niu0217:~/Dev/MyLib/dynamic_library$
```

```bash
# 查看节区头部表
ubuntu@niu0217:~/Dev/MyLib/dynamic_library$ readelf -S addvec.o
There are 21 section headers, starting at offset 0x1360:

Section Headers:
  [Nr] Name              Type             Address           Offset
       Size              EntSize          Flags  Link  Info  Align
  [ 0]                   NULL             0000000000000000  00000000
       0000000000000000  0000000000000000           0     0     0
  [ 1] .text             PROGBITS         0000000000000000  00000040
       0000000000000089  0000000000000000  AX       0     0     1
  [ 2] .rela.text        RELA             0000000000000000  00000c28
       0000000000000030  0000000000000018   I      18     1     8
  [ 3] .data             PROGBITS         0000000000000000  000000c9
       0000000000000000  0000000000000000  WA       0     0     1
  [ 4] .bss              NOBITS           0000000000000000  000000cc
       0000000000000004  0000000000000000  WA       0     0     4
  [ 5] .debug_info       PROGBITS         0000000000000000  000000cc
       000000000000036d  0000000000000000           0     0     1
  [ 6] .rela.debug_info  RELA             0000000000000000  00000c58
       00000000000005e8  0000000000000018   I      18     5     8
  [ 7] .debug_abbrev     PROGBITS         0000000000000000  00000439
       0000000000000103  0000000000000000           0     0     1
  [ 8] .debug_aranges    PROGBITS         0000000000000000  0000053c
       0000000000000030  0000000000000000           0     0     1
  [ 9] .rela.debug_arang RELA             0000000000000000  00001240
       0000000000000030  0000000000000018   I      18     8     8
  [10] .debug_line       PROGBITS         0000000000000000  0000056c
       000000000000014d  0000000000000000           0     0     1
  [11] .rela.debug_line  RELA             0000000000000000  00001270
       0000000000000018  0000000000000018   I      18    10     8
  [12] .debug_str        PROGBITS         0000000000000000  000006b9
       000000000000031d  0000000000000001  MS       0     0     1
  [13] .comment          PROGBITS         0000000000000000  000009d6
       000000000000002c  0000000000000001  MS       0     0     1
  [14] .note.GNU-stack   PROGBITS         0000000000000000  00000a02
       0000000000000000  0000000000000000           0     0     1
  [15] .note.gnu.propert NOTE             0000000000000000  00000a08
       0000000000000020  0000000000000000   A       0     0     8
  [16] .eh_frame         PROGBITS         0000000000000000  00000a28
       0000000000000038  0000000000000000   A       0     0     8
  [17] .rela.eh_frame    RELA             0000000000000000  00001288
       0000000000000018  0000000000000018   I      18    16     8
  [18] .symtab           SYMTAB           0000000000000000  00000a60
       0000000000000198  0000000000000018          19    14     8
  [19] .strtab           STRTAB           0000000000000000  00000bf8
       000000000000002f  0000000000000000           0     0     1
  [20] .shstrtab         STRTAB           0000000000000000  000012a0
       00000000000000bb  0000000000000000           0     0     1
Key to Flags:
  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),
  L (link order), O (extra OS processing required), G (group), T (TLS),
  C (compressed), x (unknown), o (OS specific), E (exclude),
  l (large), p (processor specific)
ubuntu@niu0217:~/Dev/MyLib/dynamic_library$
```

```bash
# 查看特定节区的内容
ubuntu@niu0217:~/Dev/MyLib/dynamic_library$ readelf -x .text addvec.o

Hex dump of section '.text':
 NOTE: This section has relocations against it, but these have NOT been applied to this dump.
  0x00000000 f30f1efa 554889e5 48897de8 488975e0 ....UH..H.}.H.u.
  0x00000010 488955d8 894dd448 8b050000 00008b00 H.U..M.H........
  0x00000020 8d500148 8b050000 00008910 c745fc00 .P.H.........E..
  0x00000030 000000eb 488b45fc 4898488d 14850000 ....H.E.H.H.....
  0x00000040 0000488b 45e84801 d08b088b 45fc4898 ..H.E.H.....E.H.
  0x00000050 488d1485 00000000 488b45e0 4801d08b H.......H.E.H...
  0x00000060 108b45fc 4898488d 34850000 0000488b ..E.H.H.4.....H.
  0x00000070 45d84801 f001ca89 108345fc 018b45fc E.H.......E...E.
  0x00000080 3b45d47c b090905d c3                ;E.|...].

```

```bash
# 查看符号表
ubuntu@niu0217:~/Dev/MyLib/dynamic_library$ readelf -s addvec.o

Symbol table '.symtab' contains 17 entries:
   Num:    Value          Size Type    Bind   Vis      Ndx Name
     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND
     1: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS addvec.c
     2: 0000000000000000     0 SECTION LOCAL  DEFAULT    1
     3: 0000000000000000     0 SECTION LOCAL  DEFAULT    3
     4: 0000000000000000     0 SECTION LOCAL  DEFAULT    4
     5: 0000000000000000     0 SECTION LOCAL  DEFAULT    5
     6: 0000000000000000     0 SECTION LOCAL  DEFAULT    7
     7: 0000000000000000     0 SECTION LOCAL  DEFAULT    8
     8: 0000000000000000     0 SECTION LOCAL  DEFAULT   10
     9: 0000000000000000     0 SECTION LOCAL  DEFAULT   12
    10: 0000000000000000     0 SECTION LOCAL  DEFAULT   14
    11: 0000000000000000     0 SECTION LOCAL  DEFAULT   15
    12: 0000000000000000     0 SECTION LOCAL  DEFAULT   16
    13: 0000000000000000     0 SECTION LOCAL  DEFAULT   13
    14: 0000000000000000     4 OBJECT  GLOBAL DEFAULT    4 add_cnt
    15: 0000000000000000   137 FUNC    GLOBAL DEFAULT    1 addvec
    16: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND _GLOBAL_OFFSET_TABLE_
ubuntu@niu0217:~/Dev/MyLib/dynamic_library$
ubuntu@niu0217:~/Dev/MyLib/test_dynamic_library$ readelf -s main.o

Symbol table '.symtab' contains 22 entries:
   Num:    Value          Size Type    Bind   Vis      Ndx Name
     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND
     1: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS main.c
     2: 0000000000000000     0 SECTION LOCAL  DEFAULT    1
     3: 0000000000000000     0 SECTION LOCAL  DEFAULT    3
     4: 0000000000000000     0 SECTION LOCAL  DEFAULT    4
     5: 0000000000000000     0 SECTION LOCAL  DEFAULT    5
     6: 0000000000000000     0 SECTION LOCAL  DEFAULT    6
     7: 0000000000000000     0 SECTION LOCAL  DEFAULT    8
     8: 0000000000000000     0 SECTION LOCAL  DEFAULT    9
     9: 0000000000000000     0 SECTION LOCAL  DEFAULT   11
    10: 0000000000000000     0 SECTION LOCAL  DEFAULT   13
    11: 0000000000000000     0 SECTION LOCAL  DEFAULT   15
    12: 0000000000000000     0 SECTION LOCAL  DEFAULT   16
    13: 0000000000000000     0 SECTION LOCAL  DEFAULT   17
    14: 0000000000000000     0 SECTION LOCAL  DEFAULT   14
    15: 0000000000000000     8 OBJECT  GLOBAL DEFAULT    3 x
    16: 0000000000000008     8 OBJECT  GLOBAL DEFAULT    3 y
    17: 0000000000000008     8 OBJECT  GLOBAL DEFAULT  COM z
    18: 0000000000000000    77 FUNC    GLOBAL DEFAULT    1 main
    19: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND _GLOBAL_OFFSET_TABLE_
    20: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND addvec
    21: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND printf
ubuntu@niu0217:~/Dev/MyLib/test_dynamic_library$
```

```bash
# 查看重定位条目
ubuntu@niu0217:~/Dev/MyLib/test_dynamic_library$ readelf -r main.o

Relocation section '.rela.text' at offset 0xc08 contains 8 entries:
  Offset          Info           Type           Sym. Value    Sym. Name + Addend
000000000010  001100000002 R_X86_64_PC32     0000000000000008 z - 4
000000000017  001000000002 R_X86_64_PC32     0000000000000008 y - 4
00000000001e  000f00000002 R_X86_64_PC32     0000000000000000 x - 4
000000000023  001400000004 R_X86_64_PLT32    0000000000000000 addvec - 4
000000000029  001100000002 R_X86_64_PC32     0000000000000008 z + 0
00000000002f  001100000002 R_X86_64_PC32     0000000000000008 z - 4
000000000038  000500000002 R_X86_64_PC32     0000000000000000 .rodata - 4
000000000042  001500000004 R_X86_64_PLT32    0000000000000000 printf - 4

Relocation section '.rela.debug_info' at offset 0xcc8 contains 64 entries:
  Offset          Info           Type           Sym. Value    Sym. Name + Addend
000000000006  00070000000a R_X86_64_32       0000000000000000 .debug_abbrev + 0
00000000000c  000a0000000a R_X86_64_32       0000000000000000 .debug_str + 192
000000000011  000a0000000a R_X86_64_32       0000000000000000 .debug_str + 26b
000000000015  000a0000000a R_X86_64_32       0000000000000000 .debug_str + 111
000000000019  000200000001 R_X86_64_64       0000000000000000 .text + 0
000000000029  00090000000a R_X86_64_32       0000000000000000 .debug_line + 0
00000000002e  000a0000000a R_X86_64_32       0000000000000000 .debug_str + 17
00000000003c  000a0000000a R_X86_64_32       0000000000000000 .debug_str + a7
000000000043  000a0000000a R_X86_64_32       0000000000000000 .debug_str + 47
00000000004c  000a0000000a R_X86_64_32       0000000000000000 .debug_str + 83
000000000053  000a0000000a R_X86_64_32       0000000000000000 .debug_str + b9
00000000005a  000a0000000a R_X86_64_32       0000000000000000 .debug_str + 2ec
000000000061  000a0000000a R_X86_64_32       0000000000000000 .debug_str + 28c
00000000006f  000a0000000a R_X86_64_32       0000000000000000 .debug_str + 2b8
000000000074  000a0000000a R_X86_64_32       0000000000000000 .debug_str + 245
000000000080  000a0000000a R_X86_64_32       0000000000000000 .debug_str + 0
0000000000a4  000a0000000a R_X86_64_32       0000000000000000 .debug_str + 272
0000000000ae  000a0000000a R_X86_64_32       0000000000000000 .debug_str + 1e
0000000000bb  000a0000000a R_X86_64_32       0000000000000000 .debug_str + 2a6
0000000000c8  000a0000000a R_X86_64_32       0000000000000000 .debug_str + 33
0000000000d5  000a0000000a R_X86_64_32       0000000000000000 .debug_str + a
0000000000e2  000a0000000a R_X86_64_32       0000000000000000 .debug_str + 2f8
0000000000ef  000a0000000a R_X86_64_32       0000000000000000 .debug_str + 2dd
0000000000fc  000a0000000a R_X86_64_32       0000000000000000 .debug_str + 2c1
000000000109  000a0000000a R_X86_64_32       0000000000000000 .debug_str + 27e
000000000116  000a0000000a R_X86_64_32       0000000000000000 .debug_str + 185
000000000123  000a0000000a R_X86_64_32       0000000000000000 .debug_str + 27
000000000130  000a0000000a R_X86_64_32       0000000000000000 .debug_str + 75
00000000013d  000a0000000a R_X86_64_32       0000000000000000 .debug_str + 296
00000000014a  000a0000000a R_X86_64_32       0000000000000000 .debug_str + d2
000000000157  000a0000000a R_X86_64_32       0000000000000000 .debug_str + ea
000000000164  000a0000000a R_X86_64_32       0000000000000000 .debug_str + 6e
000000000171  000a0000000a R_X86_64_32       0000000000000000 .debug_str + 17d
00000000017e  000a0000000a R_X86_64_32       0000000000000000 .debug_str + fd
00000000018b  000a0000000a R_X86_64_32       0000000000000000 .debug_str + 105
000000000198  000a0000000a R_X86_64_32       0000000000000000 .debug_str + 14e
0000000001a5  000a0000000a R_X86_64_32       0000000000000000 .debug_str + 21f
0000000001b2  000a0000000a R_X86_64_32       0000000000000000 .debug_str + 306
0000000001bf  000a0000000a R_X86_64_32       0000000000000000 .debug_str + 13d
0000000001cc  000a0000000a R_X86_64_32       0000000000000000 .debug_str + 54
0000000001d9  000a0000000a R_X86_64_32       0000000000000000 .debug_str + 22e
0000000001e6  000a0000000a R_X86_64_32       0000000000000000 .debug_str + 2ad
0000000001f3  000a0000000a R_X86_64_32       0000000000000000 .debug_str + 237
000000000200  000a0000000a R_X86_64_32       0000000000000000 .debug_str + 91
00000000020d  000a0000000a R_X86_64_32       0000000000000000 .debug_str + 40
00000000021a  000a0000000a R_X86_64_32       0000000000000000 .debug_str + 5c
000000000227  000a0000000a R_X86_64_32       0000000000000000 .debug_str + 24d
000000000235  000a0000000a R_X86_64_32       0000000000000000 .debug_str + f8
000000000241  000a0000000a R_X86_64_32       0000000000000000 .debug_str + df
000000000249  000a0000000a R_X86_64_32       0000000000000000 .debug_str + 143
000000000270  000a0000000a R_X86_64_32       0000000000000000 .debug_str + 171
00000000027b  000a0000000a R_X86_64_32       0000000000000000 .debug_str + 2cf
000000000296  000a0000000a R_X86_64_32       0000000000000000 .debug_str + cc
0000000002a8  000a0000000a R_X86_64_32       0000000000000000 .debug_str + 264
0000000002b4  000a0000000a R_X86_64_32       0000000000000000 .debug_str + 277
0000000002c0  000a0000000a R_X86_64_32       0000000000000000 .debug_str + 9e
0000000002e7  000a0000000a R_X86_64_32       0000000000000000 .debug_str + 62
0000000002f5  000a0000000a R_X86_64_32       0000000000000000 .debug_str + 256
0000000002fc  000a0000000a R_X86_64_32       0000000000000000 .debug_str + 15a
00000000030c  000f00000001 R_X86_64_64       0000000000000000 x + 0
000000000320  001000000001 R_X86_64_64       0000000000000008 y + 0
000000000334  001100000001 R_X86_64_64       0000000000000008 z + 0
00000000033d  000a0000000a R_X86_64_32       0000000000000000 .debug_str + f3
000000000348  000200000001 R_X86_64_64       0000000000000000 .text + 0

Relocation section '.rela.debug_aranges' at offset 0x12c8 contains 2 entries:
  Offset          Info           Type           Sym. Value    Sym. Name + Addend
000000000006  00060000000a R_X86_64_32       0000000000000000 .debug_info + 0
000000000010  000200000001 R_X86_64_64       0000000000000000 .text + 0

Relocation section '.rela.debug_line' at offset 0x12f8 contains 1 entry:
  Offset          Info           Type           Sym. Value    Sym. Name + Addend
0000000000fb  000200000001 R_X86_64_64       0000000000000000 .text + 0

Relocation section '.rela.eh_frame' at offset 0x1310 contains 1 entry:
  Offset          Info           Type           Sym. Value    Sym. Name + Addend
000000000020  000200000002 R_X86_64_PC32     0000000000000000 .text + 0
ubuntu@niu0217:~/Dev/MyLib/test_dynamic_library$
```

### 5.3 nm

```bash
# 列出所有符号
ubuntu@niu0217:~/Dev/MyLib/test_dynamic_library$ nm main.o
                 U addvec
                 U _GLOBAL_OFFSET_TABLE_
0000000000000000 T main
                 U printf
0000000000000000 D x
0000000000000008 D y
0000000000000008 C z
ubuntu@niu0217:~/Dev/MyLib/test_dynamic_library$
```

```bash
# 显示未定义的符号

```

```bash
```

```bash
```

```bash
```

```bash
```

```bash
```

```bash
```

```bash
```

```bash