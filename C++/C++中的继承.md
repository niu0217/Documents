# C++中的继承

## 1. 问题

## 2. 继承方式

### 2.1 公有继承

**公有继承（Public Inheritance）**：

- 派生类公开继承基类的公共和保护成员。
- 派生类的对象可以被当作基类的对象来使用，这是多态的基础

```c++
class Base {
public:
    void publicFunc() {}
protected:
    void protectedFunc() {}
private:
    void privateFunc() {} // 不可访问
};

class Derived : public Base {
public:
    void derivedFunc() {}
};
```

### 2.2 私有继承

**私有继承（Private Inheritance）：**

- 派生类继承了基类的所有成员，但基类的公共和保护成员在派生类中变为私有成员。
- 派生类的对象不能被当作基类的对象来使用。

```c++
class Derived : private Base {
public:
    void derivedFunc() {}
};
```

**派生类的对象不能被当作基类的对象来使用是什么意思？**

- 在私有继承中，基类的公共和保护成员在派生类中变为私有成员。由于私有成员对外部代码（包括派生类的外部代码）不可见，所以不能直接通过派生类的对象访问这些原本在基类中是公共或保护的成员。因此，你不能将派生类的对象赋值给基类的引用或指针，也不能通过基类的引用来调用派生类对象的函数。
- 在受保护继承中，基类的公共成员在派生类中变为保护成员。虽然派生类的子类可以访问这些保护成员，但外部代码仍然不能直接通过派生类的对象访问它们。因此，同样不能将派生类的对象当作基类的对象来使用。

然而，对于公有继承，情况就不同了。在公有继承中，派生类的对象可以被当作基类的对象来使用。这意味着你可以将派生类的对象赋值给基类的引用或指针，并通过这些引用来调用派生类对象的函数。这是多态性的一个基础，使得你可以使用基类的接口来操作不同类型（即派生类）的对象。

### 2.3 受保护继承

**受保护继承（Protected Inheritance）：**

- 派生类继承了基类的所有成员，但基类的公共成员在派生类中变为保护成员。
- 派生类的对象不能被当作基类的对象来使用。

```c++
class Derived : protected Base {
public:
    void derivedFunc() {}
};
```

## 3. 其余知识

### 3.1 基类初始化

在派生类的构造函数初始化列表中，可以初始化基类的构造函数。

```c++
class Derived : public Base {
public:
    Derived(int value) : Base(value) {} // 初始化基类Base
};
```

### 3.2 继承和访问权限

+ 派生类可以访问基类的公共和保护成员。

- 派生类不能访问基类的私有成员。
- **派生类的外部代码只能访问派生类的公共成员和基类的公共/受保护成员。**

### 3.3 虚函数和多态

- 通过在基类中声明虚函数（使用`virtual`关键字），可以在派生类中重写该函数以实现运行时多态。
- 当通过基类指针或引用调用虚函数时，会根据实际对象的类型调用相应的函数。

```c++
class Base {
public:
    virtual void func() { std::cout << "Base" << std::endl; }
};

class Derived : public Base {
public:
    void func() override { std::cout << "Derived" << std::endl; }
};
```

通过继承，C++允许代码重用、层次化设计和多态性，使得程序更加灵活和模块化。然而，过度使用继承或者设计不当可能会导致复杂性和维护性问题，因此在设计类层次结构时需要谨慎考虑。