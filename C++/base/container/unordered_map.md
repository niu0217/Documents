# unordered_map

## 1. 问题

## 2. 引入代码

```c++
#include <iostream>
#include <unordered_map>

int main() {
    // 1. 创建一个空的unordered_map，键为字符串类型，值为整型
    std::unordered_map<std::string, int> myMap;

    // 2. 插入元素 (Insertion)
    myMap["apple"] = 5; // 使用下标运算符插入或更新元素
    myMap.insert({{"banana", 7}, {"cherry", 9}});
    myMap.emplace("date", 10); // 使用emplace构造并插入

    // 3. 查找元素 (Search)
    auto it = myMap.find("apple");
    if (it != myMap.end()) {
        std::cout << "Value for 'apple': " << it->second << '\n';
    } else {
        std::cout << "'apple' not found.\n";
    }

    // 4. 计算元素数量 (Count)
    size_t count = myMap.count("banana");
    std::cout << "Number of occurrences of 'banana': " << count << '\n';

    // 5. 遍历所有元素 (Traversal)
    for (const auto& entry : myMap) {
        std::cout << "Key: " << entry.first << ", Value: " << entry.second << '\n';
    }

    // 6. 删除单个元素 (Deletion - Single Element)
    myMap.erase("apple"); // 删除键为"apple"的所有条目（在这种情况下只有一个）

    // 8. 其他函数：
    // 获取容器大小
    size_t size = myMap.size();
    std::cout << "Size of the map: " << size << '\n';
  
  	// 7. 清空整个容器 (Clear)
    myMap.clear();

    // 检查容器是否为空
    bool isEmpty = myMap.empty();
    std::cout << "Is the map empty? " << (isEmpty ? "Yes" : "No") << '\n';

    return 0;
}
```

**注意**：

- `std::unordered_map`中的元素是无序的，不保证迭代器遍历时元素的顺序。
- 虽然不能直接修改已存在元素的键，但可以通过删除旧键值对并插入新键值对来间接“修改”键。

其他功能还包括：

- `at(key)`：与`find()`类似，但是当键不存在时会抛出异常。
- `equal_range(key)`：对于`unordered_map`来说，此函数等同于`find(key)`，因为它不允许键重复。
- `bucket_count()` 和 `load_factor()`：用于获取哈希表桶的数量和负载因子。
- `reserve(capacity)`：预分配足够的空间以容纳至少指定数量的元素，减少可能的重新哈希操作。

## 3. 原理

`std::unordered_map`在C++标准库中的实现基于哈希表（Hash Table）数据结构。以下是其基本原理：

1. **哈希函数**：每个键值对插入到`unordered_map`时，首先通过一个哈希函数计算出对应的哈希值。这个哈希值通常是一个整数，用于确定键值对应该存储在哈希表数组的哪个槽位。
2. **桶（Bucket）**：哈希表由一系列桶组成，每个桶内可以包含零个或多个元素。当两个键映射到相同的哈希值时，就会发生哈希冲突。
3. **解决冲突**：为了处理哈希冲突，`std::unordered_map`通常采用链地址法（Separate Chaining），即为每个桶关联一个链表或者其他容器来存储所有哈希值相同但键不同的元素。当查找、插入或删除元素时，先通过哈希函数找到桶的位置，然后在桶内的链表中执行相应的操作。
4. **负载因子和扩容**：为了避免过多的哈希冲突影响性能，`std::unordered_map`会根据当前元素数量与桶数量的比例（即负载因子）决定是否需要扩容。当负载因子超过一定阈值时，容器将自动创建一个新的更大的哈希表，并将所有元素重新哈希到新的表中，从而降低冲突概率。
5. **迭代器稳定性**：由于元素可能会因为哈希表的扩容而被重新排列和移动，因此在执行插入和删除操作后，除了指向已删除元素的迭代器外，其他迭代器可能失效。

综上所述，`std::unordered_map`利用哈希表技术实现了快速的增删查改操作，其具体性能取决于哈希函数的质量、负载因子控制以及解决冲突的方法等。

## 4. 优点和缺点

**优点：**

1. **高效查找**：`std::unordered_map`基于哈希表实现，插入、删除和查找操作在理想情况下具有O(1)的平均时间复杂度。这意味着对于大量数据的增删查改操作，它能够提供快速响应。
2. **键值对存储**：提供了键值对（key-value pair）的存储方式，非常适合需要通过特定键快速访问关联值的场景。
3. **空间效率**：虽然存在冲突时可能需要额外的空间来存储链表结构以解决哈希冲突，但在合理设计下，`std::unordered_map`仍能保持较好的空间效率。
4. **内存自动管理**：容器自动处理元素的内存分配和释放，用户无需手动管理内存。
5. **迭代器遍历**：虽然元素在物理存储上无序，但可以通过迭代器遍历集合内的所有键值对。

**缺点：**

1. **哈希碰撞**：当哈希函数质量不高或输入数据分布不均导致过多哈希冲突时，查找、插入和删除的性能会退化至接近O(n)。尤其是在负载因子过高时，冲突增加可能导致性能显著降低。
2. **顺序不确定性**：`std::unordered_map`内部是无序的，无法保证元素的存储顺序，这在某些依赖元素顺序的场合可能会成为限制。
3. **迭代器失效**：插入和删除操作可能导致其他元素的位置发生变化，因此除了被删除元素的迭代器外，其他迭代器在这些操作后可能失效。
4. **初始化和重新哈希**：当容器需要扩容以降低负载因子时，需要对所有元素进行重新哈希并迁移至新的哈希表，这是一个耗时的过程，在大量元素的情况下尤其明显。
5. **空间浪费**：为了处理哈希冲突而预留的桶可能在低负载因子或者数据分布特别均匀的情况下造成一定的空间浪费。
6. **对键的要求**：键类型必须支持哈希运算和等于运算符，并且要求这两个运算符的结果必须一致，即如果两个键相等，则它们的哈希值也必须相等。这对于自定义类型作为键的情况增加了额外的约束。
7. **哈希函数质量影响性能**：内置的哈希函数可能不适合某些特定的数据分布，有时需要为自定义类型提供一个好的哈希函数以获得更好的性能。

## 5. 增删查改的效率

C++标准库中的`std::unordered_map`基于哈希表实现，其增删查改操作在理想情况下的时间复杂度期望为O(1)：

1. **插入（Insertion）**：
   - 插入一个键值对时，首先通过哈希函数计算出键对应的桶位置。如果该位置上没有冲突或冲突较少，则插入操作可以快速完成，平均时间复杂度为O(1)。然而，当桶内已经存在大量冲突，新元素会被附加到链表中，这可能会增加插入的时间成本。
2. **查找（Search）**：
   - 查找特定键时同样先通过哈希函数定位到相应的桶，然后遍历桶内的链表以找到匹配项。在理想情况下，即使桶内存在冲突，但只要冲突数量不是太大，查找时间复杂度仍接近O(1)。
3. **删除（Deletion）**：
   - 删除键值对时，需要先通过哈希函数找到目标键所在的桶，并从桶内关联的链表或其他数据结构中移除该键值对。删除操作通常也能在O(1)时间内完成，前提是能迅速定位到待删除元素。
4. **修改（Modification）**：
   - 修改键值对中的值可以通过直接访问容器内的元素来完成，这个操作时间复杂度接近于O(1)，因为不需要重新计算哈希值或调整桶的位置。但是，如果试图修改键本身，实际上会导致旧键值对被删除并插入新的键值对，因此涉及两次操作（删除和插入），但在最坏情况下都保持O(1)的理想效率。

需要注意的是，在最坏情况下，当哈希函数质量不高导致哈希碰撞过多，或者负载因子过高时，上述操作的实际性能可能退化至O(n)，其中n表示容器中元素的数量。为了避免这种情况，标准库会动态调整容器大小以保持较低的负载因子，并尽量减少冲突。