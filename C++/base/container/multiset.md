# multiset

## 1. 问题

## 2. 引入代码

```c++
#include <iostream>
#include <set>

int main() {
    // 创建一个整数多重集合
    std::multiset<int> myMultiset;

    // 插入元素（增）
    myMultiset.insert(3);
    myMultiset.insert(1);
    myMultiset.insert(5);
    myMultiset.insert(1); // 多重集合允许插入重复元素

    // 查找元素（查）
    if (myMultiset.find(3) != myMultiset.end()) {
        std::cout << "Element 3 is found in the multiset.\n";
    } else {
        std::cout << "Element 3 is not found in the multiset.\n";
    }

    // 删除元素（删）
    myMultiset.erase(3);

    // 遍历集合（查）
    for (const auto& element : myMultiset) {
        std::cout << "Element: " << element << "\n";
    }

    // 修改元素的值（由于 std::multiset 不直接支持修改键值，需要先删除旧元素，然后插入新元素）
    int oldValue = 1;
    int newValue = 4;
    auto it = myMultiset.find(oldValue);
    while (it != myMultiset.end() && *it == oldValue) {
        myMultiset.erase(it++);
    }
    myMultiset.insert(newValue);

    return 0;
}
```

在这个示例中，我们使用了 C++ 标准库中的 `std::multiset`，并演示了以下操作：

- 插入元素（增）：通过 `insert()` 函数将元素添加到多重集合中。`std::multiset` 允许插入重复元素。
- 查找元素（查）：使用 `find()` 函数查找多重集合中是否存在指定的元素。
- 删除元素（删）：通过 `erase()` 函数从多重集合中删除指定的元素。
- 遍历集合（查）：使用范围for循环遍历多重集合中的所有元素。
- 修改元素（改）：由于 `std::multiset` 不直接支持修改键值，我们首先使用 `find()` 函数找到旧元素的位置，然后使用 `erase()` 函数删除所有匹配的旧元素，最后使用 `insert()` 函数插入新元素。

## 3. 原理

multiset的实现原理通常基于平衡搜索树数据结构，具体在许多标准库（如C++的STL）中，multiset底层是通过红黑树（Red-Black Tree）来实现的。

以下是如何使用红黑树实现multiset的一些关键特性：

1. **自动排序**：红黑树是一种自平衡二叉搜索树，它保证了任何插入、删除和查找操作的时间复杂度都是O(log n)，其中n是树中的元素数量。这种特性使得multiset能够自动对其存储的元素进行排序。
2. **元素重复**：与set不同，multiset允许元素重复。在红黑树中，这通过将相同的元素作为独立的节点存储来实现，每个节点都保持其自身的键值和颜色属性。
3. **插入操作**：当插入一个新元素时，红黑树的规则会确保插入后的树仍然是平衡的。这个过程可能涉及到颜色翻转和旋转等操作来维护红黑树的性质。
4. **删除操作**：删除元素时，也需要更新树的结构以保持平衡。这可能包括找到要删除元素的替代节点（例如，最小的后继节点或最大的前驱节点），然后执行相应的颜色更改和旋转。
5. **查找操作**：由于红黑树的性质，查找操作可以通过从根节点开始并按照键值比较向下遍历树来高效完成。
6. **迭代器稳定性**：在红黑树上进行插入和删除操作通常不会改变其他元素的相对顺序，因此multiset的迭代器在这些操作后通常保持有效（除非删除了当前迭代器所指向的元素）。

需要注意的是，不同的编程语言或库可能会选择不同的数据结构来实现multiset，但红黑树是一种常见的选择，因为它提供了良好的性能保证和易于实现的自平衡特性。在C++的STL中，除了红黑树，也有可能使用哈希表（如unordered_multiset）来实现，这取决于具体的实现和性能需求。

## 4. 优点和缺点

以下是multiset（基于红黑树实现）的优点和缺点：

优点：

1. **自动排序**：multiset中的元素总是按照特定的排序规则（默认是升序）排列，这使得查找、插入和删除操作变得更加方便。
2. **高效操作**：由于使用了平衡搜索树（如红黑树），插入、删除和查找操作的时间复杂度都是O(log n)，在处理大量数据时具有良好的性能。
3. **元素重复**：与set不同，multiset允许元素重复，这对于需要存储和操作多个相同元素的场景非常有用。
4. **迭代器稳定性**：在插入和删除操作后，除了被删除的元素之外，其他元素的迭代器通常保持有效，这使得在遍历集合时可以更安全地进行修改。
5. **内存效率**：尽管不是最节省内存的数据结构，但红黑树的自平衡特性使得multiset在大多数情况下能够提供较好的空间效率。

缺点：

1. **空间开销**：每个元素都需要存储键值和颜色信息，以及指向父节点和子节点的指针，这导致了额外的空间开销。
2. **插入和删除的复杂性**：虽然插入和删除操作的时间复杂度是O(log n)，但实际实现中可能涉及到颜色翻转和旋转等操作，这些操作可能会增加代码的复杂性和出错的可能性。
3. **随机访问**：虽然可以通过迭代器访问multiset中的元素，但不支持像数组那样的直接索引访问，即不能通过元素的位置快速获取元素。
4. **非线性时间的特定操作**：某些操作，如在multiset中查找特定排名的元素或获取元素的数量，可能需要O(n)的时间。
5. **初始化和复制**：创建一个新的multiset或者复制一个现有的multiset可能需要O(n)的时间和空间，其中n是元素数量。

总的来说，multiset适用于需要保持元素有序、允许元素重复且对插入、删除和查找操作有较高性能要求的场景。然而，如果对内存使用、代码复杂性或特定操作的性能有严格要求，可能需要考虑其他数据结构。

## 5. 增删查改的效率

在基于红黑树实现的multiset中，增删查改的效率如下：

1. **插入（Insertion）**：插入一个元素的时间复杂度为O(log n)，其中n是multiset中的元素数量。这是因为红黑树是一种自平衡二叉搜索树，插入新元素后可以通过颜色翻转和旋转等操作来保持树的平衡，从而确保插入操作的时间复杂度为对数级别。
2. **删除（Deletion）**：删除一个元素的时间复杂度也为O(log n)。删除操作需要找到要删除的元素，然后可能需要进行一些调整（如颜色翻转和旋转）以保持树的平衡，但总体上时间复杂度仍然是对数级别的。
3. **查找（Search）**：查找一个元素的时间复杂度为O(log n)。在multiset中查找元素时，可以从根节点开始按照排序规则向下遍历树，直到找到目标元素或者确定元素不存在。
4. **修改（Modification）**：multiset本身不直接支持修改元素的操作，因为元素被视为不可变的键。如果需要修改元素的值，通常需要先删除旧元素，然后插入新元素。因此，修改操作的时间复杂度实际上是删除和插入操作的组合，即O(log n) + O(log n) = O(log n)。

总的来说，基于红黑树的multiset在增删查改方面的效率都相对较高，都是O(log n)的时间复杂度。这种效率对于处理大量数据和需要频繁进行这些操作的场景非常有利。然而，需要注意的是，实际的运行时间还取决于硬件性能、数据结构的具体实现以及其他因素。