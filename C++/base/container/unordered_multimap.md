# unordered_multimap

## 1. 问题

## 2. 引入代码

```c++
#include <iostream>
#include <unordered_map>

int main() {
    // 创建一个无序多重映射，键为字符串类型，值为整型
    std::unordered_multimap<std::string, int> myMultimap;

    // 插入元素 (Insertion)
    myMultimap.insert({"apple", 5});
    myMultimap.insert({{"banana", 7}, {"apple", 10}}); // 可以插入相同键但不同值的项
    myMultimap.emplace("cherry", 9);

    // 查找元素 (Search)
    auto range = myMultimap.equal_range("apple");
    for (auto it = range.first; it != range.second; it++) {
        auto& entry = *it;
        std::cout << "Key: " << entry.first << ", Value: " << entry.second << '\n';
    }

    // 删除单个元素 (Deletion - Single Element)
    for (auto it = myMultimap.begin(); it != myMultimap.end(); ++it) {
        if (it->first == "banana" && it->second == 7) { // 假设我们只想删除键为"banana"且值为7的一项
            myMultimap.erase(it);
            break; // 由于是多重映射，所以可能有多项满足条件，这里仅删除一项后退出循环
        }
    }

    // 删除所有特定键的元素 (Deletion - All Elements with a Key)
    myMultimap.erase("apple");

    // 遍历所有元素 (Traversal)
    for (const auto& entry : myMultimap) {
        std::cout << "Key: " << entry.first << ", Value: " << entry.second << '\n';
    }

    return 0;
}
```

**注意**：

- `std::unordered_multimap`允许键重复，因此查找、插入和删除需要考虑键及其对应的多个值。
- 使用`equal_range(key)`可以找到具有给定键的所有元素范围。

另外，对于修改操作（modification），由于`std::unordered_multimap`中每个元素都是不可变的，无法直接修改已存在的元素。如果要更改某个键的值，必须先删除旧的键值对，然后插入新的键值对。

## 3. 原理

`std::unordered_multimap`是C++标准库中的一个关联容器，它基于哈希表实现，允许键值对的键可以重复。以下是其基本原理：

1. **哈希函数**：与`std::unordered_map`类似，每个插入到`unordered_multimap`的键值对首先通过哈希函数计算出对应的哈希值。这个哈希值通常是一个整数，用于确定键值对在哈希表数组中的桶（bucket）位置。
2. **桶（Bucket）**：`unordered_multimap`的内部结构由一系列桶组成，每个桶内可以包含零个或多个元素。当两个键映射到相同的哈希值时，就会发生哈希冲突。
3. **解决冲突**：同样采用链地址法（Separate Chaining），即为每个桶关联一个链表或其他数据结构来存储所有哈希值相同但键可能不同的元素。每个节点存储了一个键值对，并且同一个桶内的节点形成一个链表。
4. **负载因子和扩容**：为了保持较高的查找效率，当容器中元素数量与桶数量的比例（即负载因子）超过一定阈值时，`unordered_multimap`会自动重新调整哈希表大小，并将所有元素重新哈希到新的表中，以降低冲突概率。
5. **迭代器稳定性**：由于元素可能会因为哈希表的扩容而被重新排列和移动，因此在执行插入和删除操作后，除了指向已删除元素的迭代器外，其他迭代器可能失效。

总的来说，`std::unordered_multimap`利用哈希表技术实现了快速的增删查改操作，尤其是对于键值对的查找、插入和删除，它们在理想情况下具有O(1)的平均时间复杂度。然而，实际性能取决于哈希函数的质量、负载因子控制以及解决冲突的方法等。同时，`unordered_multimap`允许多个键值对拥有相同的键，这是与`unordered_map`的主要区别。

## 4. 优点和缺点

**优点：**

1. **高效查找**：`std::unordered_multimap`基于哈希表实现，插入、删除和查找操作在平均情况下具有O(1)的时间复杂度，这使得对于大量数据的增删查改操作，它能够提供快速响应。
2. **键值对重复**：与`std::unordered_map`不同，`std::unordered_multimap`允许键值对中的键可以重复出现。这对于需要记录每个键对应多个值的情况非常有用，例如存储用户ID及其关联的不同类型的事件等。
3. **空间效率**：虽然存在冲突时可能需要额外的空间来存储链表结构以解决哈希冲突，但在合理设计下，`std::unordered_multimap`仍能保持较好的空间效率。
4. **内存自动管理**：容器自动处理元素的内存分配和释放，无需手动管理内存。
5. **迭代器遍历**：尽管元素在物理存储上无序，但可以通过迭代器遍历集合内的所有键值对，包括拥有相同键的所有项。

**缺点：**

1. **哈希碰撞**：当哈希函数质量不高或输入数据分布不均导致过多哈希冲突时，查找、插入和删除的性能会退化至接近O(n)，尤其是在负载因子过高时。
2. **顺序不确定性**：`std::unordered_multimap`内部是无序的，无法保证元素的存储顺序，这在某些依赖元素顺序的场合可能会成为限制。
3. **迭代器失效**：插入和删除操作可能导致其他元素的位置发生变化，因此除了被删除元素的迭代器外，其他迭代器在这些操作后可能失效。
4. **初始化和重新哈希**：当容器需要扩容以降低负载因子时，需要对所有元素进行重新哈希并迁移至新的哈希表，这是一个耗时的过程，在大量元素的情况下尤其明显。
5. **空间浪费**：为了处理哈希冲突而预留的桶可能在低负载因子或者数据分布特别均匀的情况下造成一定的空间浪费。
6. **对键的要求**：键类型必须支持哈希运算和等于运算符，并且要求这两个运算符的结果必须一致，即如果两个键相等，则它们的哈希值也必须相等。这对自定义类型作为键的情况增加了额外的约束。
7. **哈希函数质量影响性能**：内置的哈希函数可能不适合某些特定的数据分布，有时需要为自定义类型提供一个好的哈希函数以获得更好的性能。

## 5. 增删查改的效率

C++标准库中的`std::unordered_multimap`基于哈希表实现，其增删查改操作在理想情况下的时间复杂度期望为O(1)：

1. **插入（Insertion）**：
   - 插入一个键值对时，首先通过哈希函数计算出键对应的桶位置。如果该位置上没有冲突或冲突较少，则插入操作可以快速完成，平均时间复杂度为O(1)。然而，当桶内存在大量冲突时，新元素会被附加到链表中，这可能会增加插入的时间成本。
2. **查找（Search）**：
   - 查找特定键的任意匹配项时，先通过哈希函数定位到相应的桶，然后遍历桶内的链表以找到匹配项。在理想情况下，即使桶内存在冲突，但只要冲突数量不是太大，查找时间复杂度仍接近O(1)。
3. **删除（Deletion）**：
   - 删除键值对时，需要找到目标键所在的桶，并从桶内关联的链表或其他数据结构中移除指定的键值对。删除单个元素通常能在O(1)时间内完成，前提是能迅速定位到待删除元素。
4. **修改（Modification）**：
   - 由于`std::unordered_multimap`内部存储的键值对是不可变的，因此不能直接修改已存在的元素。若要更改某个键对应的一个或多个值，必须先删除旧的键值对，然后插入新的键值对。这个过程涉及两次操作：删除和插入，但在理想情况下，每个操作都保持O(1)的时间效率。

需要注意的是，在最坏情况下，即当哈希函数质量不高导致哈希碰撞过多，或者负载因子过高时，上述操作的实际性能可能退化至O(n)，其中n表示容器中元素的数量。为了避免这种情况，标准库会动态调整容器大小以保持较低的负载因子，并尽量减少冲突。此外，对于具有相同键的多个键值对，查找、插入和删除特定键值对的效率还取决于同一桶内链表的长度。