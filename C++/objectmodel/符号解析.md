# 符号解析

## 1. 简介

链接器解析符号引用的方法是将每个引用与它输入的可重定位目标文件中的符号表中的一个确定的符号关联起来。对那些和引用定义在相同模块中的局部符号的引用，符号解析是非常简单明了的。编译器只允许每个模块中每个局部符号有一个定义。静态局部变量也会有本地链接器符号，编译器还要确保它们拥有唯一的名字。

不过，对于全局符号的引用解析就棘手很多。当编译器遇到一个不是在当前模块中定义的符号（变量或函数名）时，会假设该符号是在其他模块中定义的，生成一个链接器符号表条目，并把它交给链接器处理。如果链接器在它的任何输入模块中都找不到这个被引用符号的定义，就输出一条（通常很难阅读的）错误信息并终止。

## 2. 链接器如何解析多重定义的全局符号

链接器的输入是一组可重定位目标模块。每个模块定义一组符号，有些是局部的（只对定义该符号的模块可见），有些是全局的（对其他模块也可见）。如果多个模块定义同名的全局符号，链接器有自己的处理方式，如下：

在编译时，编译器向汇编器输出每个全局符号，或者是强，或者是弱，而汇编器把这个信息隐含地编码在可重定位目标文件的符号表中。

+ 函数和已初始化的全局变量是强符号；

+ 未初始化的全局变量是弱符号；

根据强弱符号的定义，Linux链接器使用下面的规则来处理多重定义的符号名：

+ 规则1：不允许有多个同名的强符号；
+ 规则2：如果有一个强符号和多个弱符号同名，则选择强符号；
+ 规则3：如果有多个弱符号同名，则从这些弱符号中随机选择一个；

**举例：**

（1）例子1

```c++
//foo1.c

int main()
{
  return 0;
}
```

```c++
//bar1.c
int main()
{
  return 0;
}
```

编译器在编译两个文件的时候会报错，因为函数main是强符号，并且在foo1.c和bar1.c都有定义，所以违反了规则1。

（2）例子2

```c++
//foo2.c
int x = 15213;

int main()
{
  return 0;
}
```

```c++
//bar2.c
int x = 15213;

void f()
{
  
}
```

编译器在编译两个文件的时候会报错。因为x在foo2.c和bar2.c都进行了定义，并且x是全局变量，所以x在foo2.c和bar2.c中都是强符号，违反了规则1。

（3）例子3

```c++
//foo3.c
#include<stdio.h>
void f(void);

int x = 15213;

int main()
{
  f();
  printf("x=%d\n",x);
  return 0;
}
```

```c++
//bar3.c
int x;
void f()
{
  x = 15212;
}
```

在这个例子中，函数f在foo3.c没定义，所以链接的时候会找到bar3.c中的已经定义的函数f。符合规则2。

（4）例子4

```c++
//foo4.c

#include<stdio.h>
void f(void);

int x;

int main()
{
  x = 15213;
  f();
  printf("x=%d\n",x);
  return 0;
}
```

```c++
//bar4.c

int x;

void f()
{
  x = 15312;
}
```

在这个例子中，符号x在foo4.c和bar4.c都没有初始化，所以是两个弱符号，链接器随机选择一个。符合规则3。

（5）例子5

```c++
//foo5.c
#include<stdio.h>
void f(void);

int y = 15212;
int x = 15213;

int main()
{
  f();
  printf("x=0x%x y=0x%x \n", x, y);
  return 0;
}
```

```c++
//bar5.c
double x;

void f()
{
  x = -0.0;
}
```

编译：

```bash
gcc -Wall -o footest foo5.c bar5.c
```

执行结果：

```bash
ubuntu@niu0217:~/Dev/C++ObjectModern/objfile$ ./footest
x=0x0 y=0x3b6c
```

解释：

+ x在bar5.c中是全局符号，未初始化，所以是弱符号；
+ x在foo5.c中是全局符号，已初始化，所以是强符号；
+ 根据规则2，bar5.c中的函数f中`x = -0.0;`，这个x是foo5.c中int x，而不是bar5.c中的double x。
+ 这个时候赋值的话，就会覆盖foo5.c中y的值。很烦。

解决办法：

```bash
gcc -fno-common -o footest foo5.c bar5.c
```

告诉编译器，在遇到多重定义的全局符号时，触发一个错误。



