# 构造函数

## 编译器什么时候合成默认构造函数

### 情况一

**代码：**

```c++
//constructor.cpp

#include<iostream>

class MATX {
public:
    //缺省构造函数,即默认构造函数
    MATX() {
        std::cout<<"I am MATX\n";
    }
};

class MBTX {
public:
    int m_i;
    int m_j;
    MATX matx; //类类型成员变量
    void funct() {
        std::cout<<"IAmVeryGood"<<std::endl;
    }
};

int main()
{
    MBTX myb;
}
```

类MBTX没有任何构造函数，但包含一个类类型成员变量matx，而该类MATX有一个默认构造函数。这个时候，编译器就会为类MBTX合成一个默认构造函数，合成的目的是为了调用MATX中的默认构造函数。

换句话说：编译器合成了默认的MBTX构造函数，并且在其中安插代码，调用MATX的默认构造函数。

**执行结果：**

```bash
I am MATX
```

**分析obj文件：**

```bash
g++ -c constructor.cpp

objdump -x constructor.o > constructor.txt
```

然后编辑`constructor.txt`文件，搜索MBTX，找到关键信息：

```bash
RELOCATION RECORDS FOR [.text._ZN4MBTXC2Ev]:
OFFSET           TYPE              VALUE
000000000000001c R_X86_64_PLT32    _ZN4MATXC1Ev-0x0000000000000004
```

`_ZN4MBTXC2Ev`这个就是编译器为我们合成的MBTX的默认构造函数，它调用了`_ZN4MATXC1Ev`，而这玩意就是MATX的默认构造函数。

**丰富一下代码：**

```c++
//constructor.cpp

#include<iostream>

class MCTX {
public:
    //默认构造函数
    MCTX() {
        std::cout<<"I am MCTX\n";
    }
};

class MATX {
public:
    //缺省构造函数,即默认构造函数
    MATX() {
        std::cout<<"I am MATX\n";
    }
};

class MBTX {
public:
    int m_i;
    int m_j;
    MATX matx; //类类型成员变量
    MCTX mctx; //类类型成员变量
    void funct() {
        std::cout<<"IAmVeryGood"<<std::endl;
    }
};

int main()
{
    MBTX myb;
}
```

执行之前一样的步骤，编译成obj文件，并分析，我们直接看结果：

```bash
RELOCATION RECORDS FOR [.text._ZN4MBTXC2Ev]:
OFFSET           TYPE              VALUE
000000000000001c R_X86_64_PLT32    _ZN4MATXC1Ev-0x0000000000000004
000000000000002c R_X86_64_PLT32    _ZN4MCTXC1Ev-0x0000000000000004
```

我们看到编译器合成的MBTX的默认构造函数`_ZN4MBTXC2Ev`调用了MATX的默认构造函数`_ZN4MATXC1Ev`，还调用了MCTX的默认构造函数`_ZN4MCTXC1Ev`，和我们预期的效果一样。

### 情况二

父类带缺省构造函数，子类没有任何构造函数，那因为父类这个缺省的构造函数要被调用，所以编译器会为这个子类合成出一个默认构造函数。合成的目的是为了调用父类的缺省构造函数。

换句话说：编译器合成了默认的构造函数，并在其中安插代码，调用其父类的缺省构造函数。

**代码：**

```c++
//constructor.cpp

#include<iostream>

class MBTXParent {
public:
    MBTXParent() {
        std::cout<<"MBTXParent::MBTXParent()\n";
    }
};

class MBTX : public MBTXParent {
public:
    int m_i;
    int m_j;
    void funct() {
        std::cout<<"IAmVeryGood"<<std::endl;
    }
};

int main()
{
    MBTX myb;
}
```

和情况一一样的分析。我们直接看obj文件：

```bash
RELOCATION RECORDS FOR [.text._ZN4MBTXC2Ev]:
OFFSET           TYPE              VALUE
0000000000000018 R_X86_64_PLT32    _ZN10MBTXParentC2Ev-0x0000000000000004
```

我们看到编译器给类MBTX合成的默认构造函数`_ZN4MBTXC2Ev`调用了其父类的默认构造函数`_ZN10MBTXParentC2Ev`。

### 情况三

#### 一般情况

如果一个类含有虚函数，但该类没有任何构造函数。编译器会自动合成一个默认构造函数。主要是为了虚表指针。

**代码：**

```c++
//constructor.cpp

#include<iostream>

class MBTX {
public:
    int m_i;
    int m_j;
    virtual void myfuncVirtualOne() {
        std::cout<<"I am a virtual function one\n";
    }
    virtual void myfuncVirtualTwo() {
        std::cout<<"I am a virtual function two\n";
    }
};

int main()
{
    MBTX myb;
}
```

和情况一一样的分析方法，我们直接跳到查看obj文件：

```bash
RELOCATION RECORDS FOR [.text._ZN4MBTXC2Ev]:
OFFSET           TYPE              VALUE
000000000000000f R_X86_64_PC32     _ZTV4MBTX+0x000000000000000c


RELOCATION RECORDS FOR [.data.rel.ro.local._ZTV4MBTX]:
OFFSET           TYPE              VALUE
0000000000000008 R_X86_64_64       _ZTI4MBTX
0000000000000010 R_X86_64_64       _ZN4MBTX16myfuncVirtualOneEv
0000000000000018 R_X86_64_64       _ZN4MBTX16myfuncVirtualTwoEv
```

我猜测`_ZN4MBTXC2Ev`就是编译器生成的默认构造函数，而`_ZTV4MBTX`就是编译器在默认构造函数中插入的虚函数表指针。

`_ZN4MBTX16myfuncVirtualOneEv`和`_ZN4MBTX16myfuncVirtualTwoEv`分别是虚函数`myfuncVirtualOne`和`myfuncVirtualTwo`的地址。

#### 扩展情况

代码：

```c++
//constructor.cpp

#include<iostream>

class MBTXParent {
public:
    MBTXParent() {
        std::cout<<"MBTXParent::MBTXParent()\n";
    }
};

class MBTX : public MBTXParent {
public:
    int m_i;
    int m_j;
    MBTX() {
        m_i = 15;
    }
    virtual void myfuncVirtualOne() {
        std::cout<<"I am a virtual function one\n";
    }
    virtual void myfuncVirtualTwo() {
        std::cout<<"I am a virtual function two\n";
    }
};

int main()
{
    MBTX myb;
}
```

按照情况一的步骤分析，我们直接跳到分析obj文件：

```bash
RELOCATION RECORDS FOR [.text._ZN10MBTXParentC2Ev]:
OFFSET           TYPE              VALUE
0000000000000013 R_X86_64_PC32     .rodata-0x0000000000000003
000000000000001a R_X86_64_PC32     _ZSt4cout-0x0000000000000004
000000000000001f R_X86_64_PLT32    _ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc-0x0000000000000004


RELOCATION RECORDS FOR [.text._ZN4MBTXC2Ev]:
OFFSET           TYPE              VALUE
0000000000000018 R_X86_64_PLT32    _ZN10MBTXParentC2Ev-0x0000000000000004
000000000000001f R_X86_64_PC32     _ZTV4MBTX+0x000000000000000c


RELOCATION RECORDS FOR [.text._ZN4MBTX16myfuncVirtualOneEv]:
OFFSET           TYPE              VALUE
0000000000000013 R_X86_64_PC32     .rodata+0x0000000000000017
000000000000001a R_X86_64_PC32     _ZSt4cout-0x0000000000000004
000000000000001f R_X86_64_PLT32    _ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc-0x0000000000000004


RELOCATION RECORDS FOR [.text._ZN4MBTX16myfuncVirtualTwoEv]:
OFFSET           TYPE              VALUE
0000000000000013 R_X86_64_PC32     .rodata+0x0000000000000034
000000000000001a R_X86_64_PC32     _ZSt4cout-0x0000000000000004
000000000000001f R_X86_64_PLT32    _ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc-0x0000000000000004


RELOCATION RECORDS FOR [.data.rel.ro.local._ZTV4MBTX]:
OFFSET           TYPE              VALUE
0000000000000008 R_X86_64_64       _ZTI4MBTX
0000000000000010 R_X86_64_64       _ZN4MBTX16myfuncVirtualOneEv
0000000000000018 R_X86_64_64       _ZN4MBTX16myfuncVirtualTwoEv


RELOCATION RECORDS FOR [.data.rel.ro._ZTI4MBTX]:
OFFSET           TYPE              VALUE
0000000000000000 R_X86_64_64       _ZTVN10__cxxabiv120__si_class_type_infoE+0x0000000000000010
0000000000000008 R_X86_64_64       _ZTS4MBTX
0000000000000010 R_X86_64_64       _ZTI10MBTXParent


RELOCATION RECORDS FOR [.data.rel.ro._ZTI10MBTXParent]:
OFFSET           TYPE              VALUE
0000000000000000 R_X86_64_64       _ZTVN10__cxxabiv117__class_type_infoE+0x0000000000000010
0000000000000008 R_X86_64_64       _ZTS10MBTXParent


RELOCATION RECORDS FOR [.init_array]:
OFFSET           TYPE              VALUE
0000000000000000 R_X86_64_64       .text+0x000000000000008f


RELOCATION RECORDS FOR [.eh_frame]:
OFFSET           TYPE              VALUE
0000000000000020 R_X86_64_PC32     .text._ZN10MBTXParentC2Ev
0000000000000040 R_X86_64_PC32     .text._ZN4MBTXC2Ev
0000000000000060 R_X86_64_PC32     .text._ZN4MBTX16myfuncVirtualOneEv
0000000000000080 R_X86_64_PC32     .text._ZN4MBTX16myfuncVirtualTwoEv
00000000000000a0 R_X86_64_PC32     .text
00000000000000c0 R_X86_64_PC32     .text+0x0000000000000042
00000000000000e0 R_X86_64_PC32     .text+0x000000000000008f
```

由下可知：

```bash
RELOCATION RECORDS FOR [.eh_frame]:
OFFSET           TYPE              VALUE
0000000000000020 R_X86_64_PC32     .text._ZN10MBTXParentC2Ev
0000000000000040 R_X86_64_PC32     .text._ZN4MBTXC2Ev
0000000000000060 R_X86_64_PC32     .text._ZN4MBTX16myfuncVirtualOneEv
0000000000000080 R_X86_64_PC32     .text._ZN4MBTX16myfuncVirtualTwoEv
00000000000000a0 R_X86_64_PC32     .text
00000000000000c0 R_X86_64_PC32     .text+0x0000000000000042
00000000000000e0 R_X86_64_PC32     .text+0x000000000000008f
```

+ `_ZN10MBTXParentC2Ev`：父类MBTXParent的默认构造函数
+ `_ZN4MBTXC2Ev`：子类MBTX的默认构造函数
+ `_ZN4MBTX16myfuncVirtualOneEv`：子类MBTX的虚函数myfuncVirtualOne
+ `_ZN4MBTX16myfuncVirtualTwoEv`：子类MBTX的虚函数myfuncVirtualTwo

然后查看子类MBTX的默认构造函数：

```bash
RELOCATION RECORDS FOR [.text._ZN4MBTXC2Ev]:
OFFSET           TYPE              VALUE
0000000000000018 R_X86_64_PLT32    _ZN10MBTXParentC2Ev-0x0000000000000004
000000000000001f R_X86_64_PC32     _ZTV4MBTX+0x000000000000000c
```

从这里我们可以看出，我们自己定义的MBTX的构造函数被编译器自动插入了一些代码，自动调用了父类MBTXParent的默认构造函数。并且给虚表指针`_ZTV4MBTX`赋予了初值。

而虚表指针`_ZTV4MBTX`的内容如下：

```bash
RELOCATION RECORDS FOR [.data.rel.ro.local._ZTV4MBTX]:
OFFSET           TYPE              VALUE
0000000000000008 R_X86_64_64       _ZTI4MBTX
0000000000000010 R_X86_64_64       _ZN4MBTX16myfuncVirtualOneEv
0000000000000018 R_X86_64_64       _ZN4MBTX16myfuncVirtualTwoEv
```

### 情况四

如果一个类带有虚基类，那么编译器也会为它合成一个默认构造函数。



