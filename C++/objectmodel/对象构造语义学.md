# 对象构造语义学

## 1. 继承下的构造函数

某个类的构造函数中，调用一个虚函数，那么走的不是虚函数表，而是直接调用。

```c++
/* ************************************************************************
> File Name:     test.cpp
> Author:        niu0217
> Created Time:  Thu 08 Feb 2024 04:50:35 PM CST
> Description:
 ************************************************************************/

#include<iostream>
using namespace std;

class A {
public:
    A() {

    }
    virtual void myfunc() {
        cout<<"A::myfunc()\n";
    }
};

class B : public A {
public:
    B() {

    }
    virtual void myfunc() {
        cout<<"B::myfunc()\n";
    }
};

class C : public B {
public:
    C() {
        myfunc();
    }
    virtual void myfunc() {
        cout<<"C::myfunc()\n";
    }
};

int main()
{
    C cObj;

    return 0;
}
```

调试：

```c++
In file: /home/ubuntu/Dev/C++ObjectModern/constructor/test.cpp
   29 };
   30
   31 class C : public B {
   32 public:
   33     C() {
 ► 34         myfunc();
   35     }
   36     virtual void myfunc() {
   37         cout<<"C::myfunc()\n";
   38     }
   39 };

=> 0x0000555555555314 <+42>:	mov    rax,QWORD PTR [rbp-0x8]
   0x0000555555555318 <+46>:	mov    rdi,rax
   0x000055555555531b <+49>:	call   0x555555555324 <C::myfunc()>
```

## 2. 对象复制语义学

### 2.1 对象的默认复制行为

如果我们不写自己的拷贝构造函数和拷贝赋值运算符，编译器也会有默认的对象拷贝和对象赋值行为，但是是浅拷贝！！！！

如下所示：

```c++
/* ************************************************************************
> File Name:     test.cpp
> Author:        niu0217
> Created Time:  Thu 08 Feb 2024 04:50:35 PM CST
> Description:
 ************************************************************************/

#include<iostream>
using namespace std;

namespace _nmsp1
{
    class A {
    public:
        int m_i;
        int m_j;
    };
    void func() {
        A aObj;
        aObj.m_i = 15;
        aObj.m_j = 20;

        A aObj2 = aObj; //执行拷贝构造函数(如果你自己写了拷贝构造函数)

        A aObj3;
        aObj3.m_i = 30;
        aObj3.m_j = 40;

        aObj2 = aObj3; //执行拷贝赋值运算符(如果你写了拷贝赋值运算符)
    }
}

int main()
{
    _nmsp1::func();
}
```

### 2.2 拷贝构造函数

当我们提供自己的拷贝赋值运算符和拷贝构造函数时，我们就接管了系统默认的拷贝行为。

此时，我们有责任在拷贝构造函数和拷贝赋值运算符中完成对应的操作。

```c++
/* ************************************************************************
> File Name:     test.cpp
> Author:        niu0217
> Created Time:  Thu 08 Feb 2024 04:50:35 PM CST
> Description:
 ************************************************************************/

#include<iostream>
using namespace std;

namespace _nmsp1
{
    class A {
    public:
        int m_i;
        int m_j;

        A() : m_i{0}, m_j{0} { }
        A(const A& rhs) : m_i{rhs.m_i}, m_j{rhs.m_j} { }
        A& operator=(const A& rhs) {
            m_i = rhs.m_i;
            m_j = rhs.m_j;
            return *this;
        }
    };
    void func() {
        A aObj;
        aObj.m_i = 15;
        aObj.m_j = 20;

        A aObj2 = aObj; //执行拷贝构造函数(如果你自己写了拷贝构造函数)

        A aObj3;
        aObj3.m_i = 30;
        aObj3.m_j = 40;

        aObj2 = aObj3; //执行拷贝赋值运算符(如果你写了拷贝赋值运算符)
    }
}

int main()
{
    _nmsp1::func();
}
```

### 2.3 拷贝赋值运算符

同2.2拷贝构造函数。

### 2.4 禁止对象的拷贝构造和赋值

```c++
/* ************************************************************************
> File Name:     test.cpp
> Author:        niu0217
> Created Time:  Thu 08 Feb 2024 04:50:35 PM CST
> Description:
 ************************************************************************/

#include<iostream>
using namespace std;

namespace _nmsp1
{
    class A {
    public:
        A() : m_i{0}, m_j{0} { }
    private:
        A(const A& rhs) : m_i{rhs.m_i}, m_j{rhs.m_j} { }
        A& operator=(const A& rhs) {
            m_i = rhs.m_i;
            m_j = rhs.m_j;
            return *this;
        }
    public:
        int m_i;
        int m_j;
    };
    void func() {
        A aObj;
        aObj.m_i = 15;
        aObj.m_j = 20;

        A aObj2 = aObj; //会报错

        A aObj3;
        aObj3.m_i = 30;
        aObj3.m_j = 40;

        aObj2 = aObj3; //会报错
    }
}

int main()
{
    _nmsp1::func();
}
```

## 3. 析构函数语义学

### 3.1 析构函数被合成

什么情况下编译器会给我们生成一个析构函数？

#### 3.1.1 情况一

+ 如果继承了一个基类，基类中带析构函数，那么编译器就会合成一个析构函数来调用基类中的析构函数；

```c++
/* ************************************************************************
> File Name:     test.cpp
> Author:        niu0217
> Created Time:  Thu 08 Feb 2024 04:50:35 PM CST
> Description:
 ************************************************************************/

#include<iostream>
using namespace std;

namespace _nmsp2
{
    class Base {
    public:
        virtual ~Base() {
            cout<<"Base::~Base()被调用\n";
        }
    };
    class A : public Base {
    public:
    };

    void func() {
        A aObj;
    }
}

int main()
{
    _nmsp2::func();
}
```

```bash
g++ -c test.cpp

objdump -x test.o > test.txt
```

```assembly
RELOCATION RECORDS FOR [.text._ZN6_nmsp21AD2Ev]:
OFFSET           TYPE              VALUE
0000000000000013 R_X86_64_PC32     _ZTVN6_nmsp21AE+0x000000000000000c
0000000000000026 R_X86_64_PLT32    _ZN6_nmsp24BaseD2Ev-0x0000000000000004
```

`_ZN6_nmsp21AD2Ev`就是编译器为A合成的析构函数，`ZN6_nmsp24BaseD2Ev`就是Base的析构函数。

我们看到在编译器为A合成的析构函数中调用了Base的析构函数。

#### 3.1.2 情况二

+ 如果类成员是一个类类型成员，并且这个成员带析构函数，编译器也会合成一个析构函数，去调用类类型成员的析构函数；

```c++
/* ************************************************************************
> File Name:     test.cpp
> Author:        niu0217
> Created Time:  Thu 08 Feb 2024 04:50:35 PM CST
> Description:
 ************************************************************************/

#include<iostream>
using namespace std;

namespace _nmsp2
{
    class B {
    public:
        virtual ~B() {
            cout<<"B::~B()被调用\n";
        }
    };
    class A {
    public:
        B bObj;
    };

    void func() {
        A aObj;
    }
}

int main()
{
    _nmsp2::func();
}
```

```bash
g++ -c test.cpp

objdump -x test.o > test.txt
```

```assembly
RELOCATION RECORDS FOR [.text._ZN6_nmsp21AD2Ev]:
OFFSET           TYPE              VALUE
0000000000000018 R_X86_64_PLT32    _ZN6_nmsp21BD1Ev-0x0000000000000004
```

`_ZN6_nmsp21AD2Ev`就是编译器为A合成的析构函数，`_ZN6_nmsp21BD1Ev`就是类B的析构函数。

我们看到编译器为A合成的析构函数调用了类B的析构函数

### 3.2 析构函数被扩展

如果我们有自己的析构函数，那么编译器就会在适当的情况下扩展我们的析构函数代码。

#### 3.2.1 情况一

如果类成员是一个类类型成员，并且这个成员带析构函数，类比下面的`B bObj`。

此时编译器会在我们为类`A`写的析构函数中扩展代码，目的是为了调用类`B`的析构函数。

```c++
/* ************************************************************************
> File Name:     test.cpp
> Author:        niu0217
> Created Time:  Thu 08 Feb 2024 04:50:35 PM CST
> Description:
 ************************************************************************/

#include<iostream>
using namespace std;

namespace _nmsp2
{
    class B {
    public:
        virtual ~B() {
            cout<<"B::~B()被调用\n";
        }
    };
    class A {
    public:
        B bObj;
        virtual ~A() {
            cout<<"A::~A()被调用\n";
        }
    };

    void func() {
        A aObj;
    }
}

int main()
{
    _nmsp2::func();
}
```

输出结果：

```bash
A::~A()被调用
B::~B()被调用
```

#### 3.2.2 情况二

如果继承了一个基类，基类中带析构函数，那么编译器就会扩展我们自己写的析构函数来调用基类中的析构函数；

```c++
/* ************************************************************************
> File Name:     test.cpp
> Author:        niu0217
> Created Time:  Thu 08 Feb 2024 04:50:35 PM CST
> Description:
 ************************************************************************/

#include<iostream>
using namespace std;

namespace _nmsp2
{
    class Base {
    public:
        virtual ~Base() {
            cout<<"Base::~Base()被调用\n";
        }
    };
    class A : public Base {
    public:
        virtual ~A() {
            cout<<"A::~A()被调用\n";
        }
    };

    void func() {
        A aObj;
    }
}

int main()
{
    _nmsp2::func();
}
```

输出结果：

```bash
A::~A()被调用
Base::~Base()被调用
```

这里我们看到虽然我们自己没有在类`A`的析构函数中调用基类`Base`的析构函数，但是，编译器会为我们在类`A`的析构函数中插入代码，来调用基类`Base`的析构函数。

## 4. 局部对象和全局对象

### 4.1 局部对象的构造和析构

```c++
/* ************************************************************************
> File Name:     test.cpp
> Author:        niu0217
> Created Time:  Thu 08 Feb 2024 04:50:35 PM CST
> Description:
 ************************************************************************/

#include<iostream>
using namespace std;

namespace _nmsp1
{
    class A {
    public:
        A() {
            cout<<"A::A()被调用\n";
        }
        ~A() {
            cout<<"A::~A()被调用\n";
        }
    public:
        int m_i;
    };

    void func() {
        {
            A aObj;
        }
        int b = 0;
        b = 10;
    }
}

int main()
{
    _nmsp1::func();
}
```


