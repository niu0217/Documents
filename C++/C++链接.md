# C++链接

## 1. 问题

### 1.1 static问题

```c++
#include<iostream>
using namespace std;

int f() {
    static int x = 0;
    return x;
}

int g() {
    static int x = 1;
    return x;
}

int main()
{
    int f_x_static = f();
    int g_x_static = g();
    return 0;
}
```

在函数f和g中，变量x都是静态局部变量（static local variable），但是它们是两个不同的变量，具有以下不同之处：

1. **作用域（Scope）**：
   - 变量x在各自的函数f和g中具有局部作用域，这意味着它们只能在各自的函数内部被访问。
2. **生命周期（Lifetime）**：
   - 静态局部变量在第一次调用其所在函数时被初始化，并且在其生命周期内一直存在，直到程序结束。因此，对于函数f中的x和函数g中的x，它们的生命周期是独立的，分别与函数f和g的生命周期相关联。
3. **存储位置（Storage）**：
   - 虽然x是在函数内部定义的，但由于它是静态的，所以它不会存储在函数调用栈上，而是存储在程序的数据区域（data segment）中。
4. **初始化和值（Initialization and Value）**：
   - 函数f中的x被初始化为0，而函数g中的x被初始化为1。这两个变量的初始值是不同的。
5. **独立的状态（Independent State）**：
   - 每次调用函数f时，都会返回并可能修改同一个x的值（初始化为0）。
   - 同样，每次调用函数g时，都会返回并可能修改同一个x的值（初始化为1）。

因为函数f和g中的x是两个不同的静态局部变量，它们各自保持独立的状态和值，即使它们具有相同的名称。这意味着调用f()和g()将分别返回和可能修改各自独立的x变量的值。

## 2. 重要概念

### 2.1 库文件

库文件是一种包含预先编译好的程序代码和数据的文件，这些代码和数据可以在多个应用程序中重用。库文件通常包含函数、类、对象、变量等的定义和实现，可以为开发者提供便捷的功能接口，减少重复编写相同或相似功能代码的工作。

根据链接方式和使用方式的不同，库文件主要分为以下几种类型：

1. **静态库（Static Library）**：
   - 静态库文件通常以`.a`（在Unix/Linux系统中）或`.lib`（在Windows系统中）为扩展名。
   - 在链接阶段，静态库中的代码会被复制并整合到最终的可执行文件中。因此，使用静态库生成的可执行文件不依赖于外部库文件就能运行。
2. **动态库（Dynamic Library）**：
   - 动态库文件通常以`.so`（在Unix/Linux系统中，代表Shared Object）或`.dll`（在Windows系统中，代表Dynamic Link Library）为扩展名。
   - 在链接阶段，动态库中的函数和数据的引用会被加入到可执行文件中，但实际的库代码不会被复制。当程序运行时，操作系统会加载所需的动态库文件，并将库中的函数和数据绑定到程序的地址空间。
   - 使用动态库生成的可执行文件依赖于系统中存在的相应库文件，这使得动态库可以被多个程序共享，从而节省内存资源。

库文件的主要目的是提高代码的复用性、模块化和可维护性。通过使用库文件，开发者可以专注于应用程序的核心逻辑，而将一些通用的功能（如字符串操作、数学计算、图形处理等）交给库来实现。此外，库文件还可以帮助保持代码的一致性和可靠性，因为它们通常经过了广泛的测试和优化。

【这里加上自己制作动态库和静态库的文档】

### 2.2 目标文件

目标文件的主要特点包括：

- 目标文件不包含完整的可执行程序，而是程序的一部分或模块。
- 目标文件中可能包含未解析的符号引用，这些引用需要在链接阶段由链接器解析。
- 目标文件包含了重定位信息，这些信息描述了如何将目标文件中的地址引用调整为最终可执行文件中的实际地址。
- 目标文件可能还包含了调试信息，如行号、变量名等，这些信息对于调试和符号调试工具非常重要。

在完成所有源代码文件的编译并生成对应的目标文件后，链接器会将这些目标文件以及必要的库文件组合起来，生成最终的可执行文件。在这个过程中，链接器会解决目标文件之间的符号引用，调整地址引用，并确定程序在内存中的布局。

#### 2.2.1 可重定位目标文件

![image-20231224223319741](C++链接.assets/image-20231224223319741.png) 

![image-20231224223429445](C++链接.assets/image-20231224223429445.png) 

### 2.3 符号和符号表

![image-20231225090703380](C++链接.assets/image-20231225090703380.png) 

![image-20231225091724279](C++链接.assets/image-20231225091724279.png) 

## 3. 简要概述过程

C++链接是将编译生成的目标文件（Object Files）和库文件组合成一个可执行文件或动态链接库的过程。这个过程由链接器（Linker）负责执行，主要包括以下几个步骤：

1. **目标文件收集**：
   - 链接器首先收集所有需要参与链接的目标文件。这些目标文件通常是通过编译源代码文件（`.cpp`）生成的，扩展名为`.o`或`.obj`。
2. **符号解析（Symbol Resolution）**：
   - 在目标文件中，每个函数和全局变量都有一个对应的符号（Symbol）。如果一个函数或全局变量在源代码中被定义，那么它在目标文件中就是一个符号定义；如果它只被引用而没有定义，那么它就是一个符号引用。
   - 链接器需要查找所有未解析的符号引用，并试图在其他目标文件或库文件中找到相应的符号定义。
3. **重定位（Relocation）**：
   - 链接器根据符号定义的位置调整目标代码中的地址引用，确保所有的函数调用和全局变量访问都能正确地指向它们的实际位置。这个过程可能涉及到内存布局的确定和地址计算。
4. **地址空间布局（Address Space Layout）**：
   - 链接器确定程序在内存中的加载位置和布局，包括代码段、数据段、BSS段等。这一步对于程序的运行时性能和安全性都非常重要。
5. **合并目标代码和库代码**：
   - 链接器将所有必要的代码片段（来自目标文件和库文件）组合成一个单一的可执行文件或动态链接库。
6. **静态链接和动态链接**：
   - 静态链接：链接器将所有需要的库代码直接复制到可执行文件中，生成的程序不依赖外部库文件就能运行。这种方式会导致可执行文件较大，但运行时加载速度快，且不需要考虑库的版本问题。
   - 动态链接：链接器只在可执行文件中包含对所需库函数的引用，实际的库代码在程序运行时由操作系统加载。这种方式可以减少可执行文件的大小，但运行时需要依赖系统中存在的相应库文件。
7. **生成最终可执行文件或动态链接库**：
   - 完成上述步骤后，链接器生成最终的可执行文件或动态链接库，这些文件包含了程序的所有机器语言代码和数据，可以在特定平台上运行。

在实际开发中，链接过程通常由集成开发环境（IDE）或构建工具（如Makefile或CMake）自动管理。链接过程中可能出现的错误包括符号未定义、重复定义、地址冲突等问题，需要开发者进行排查和修复。

## 4. 符号解析过程



