# 库打桩机制

## 1. 问题

### 1.1 什么是库打桩机制？

库打桩（Library Interpositioning）是一种技术，通过该技术可以在运行时替换或修改程序使用的库函数的行为。这种机制允许开发者或者安全研究人员在不修改原始代码的情况下，插入自己的代码来监控、调试、优化或者控制程序的执行。

库打桩通常通过以下几种方式实现：

1. **动态链接器重定向**：在操作系统层面，可以通过修改动态链接器的配置或者使用特定的环境变量（如 `LD_PRELOAD` 在 Unix/Linux 系统中），使得在程序启动时先加载一个自定义的共享库。这个库中的函数将优先于系统库中的同名函数被调用，从而实现对库函数的替换。
2. **符号绑定**：在某些编程语言或环境中，提供了符号绑定（Symbol Binding）的功能。通过符号绑定，可以改变程序在运行时查找和调用函数的方式，使其指向自定义的函数实现。
3. **代码注入**：在程序运行时，通过修改内存中的代码或者数据，直接替换目标库函数的指令或者数据，实现对函数行为的修改。

库打桩机制在很多场景下都有应用，例如：

- 软件测试和调试：通过打桩库函数，可以监控和控制程序的执行流程，帮助发现和修复软件中的错误。
- 性能分析和优化：通过打桩库函数，可以收集程序运行时的性能数据，为优化提供依据。
- 安全增强：通过打桩库函数，可以检测和阻止潜在的安全威胁，如缓冲区溢出、非法访问等。

需要注意的是，库打桩可能会引入新的问题或者错误，因为它改变了程序原有的执行逻辑。因此，在使用库打桩时需要谨慎，并确保自定义的函数实现能够正确地处理所有可能的输入和情况。

## 2. 基本知识

### 2.1 编译时打桩

![image-20231225205702364](库打桩机制.assets/image-20231225205702364.png) 

**文件结构：**

```
interpose/
├── int.c
├── makefile
├── malloc.h
└── mymalloc.c
```

**文件：**

```c
// int.c

#include<stdio.h>
#include<malloc.h>

int main()
{
    int *p = malloc(32);
    free(p);
    return 0;
}
```

```c
// malloc.h

#define malloc(size) mymalloc(size)
#define free(ptr) myfree(ptr)

void *mymalloc(size_t size);
void myfree(void *ptr);
```

```c
// mymalloc.c

#ifdef COMPILETIME
#include<stdio.h>
#include<malloc.h>

//malloc 包装函数
void *mymalloc(size_t size) {
    void *ptr = malloc(size);
    printf("malloc(%d)=%p\n", (int)size, ptr);
    return ptr;
}

//free 包装函数
void myfree(void *ptr) {
    free(ptr);
    printf("free(%p)\n", ptr);
}
#endif
```

```makefile
# makefile

all:
	gcc -DCOMPILETIME -c mymalloc.c
	gcc -I. -o intc int.c mymalloc.o
clean:
	rm intc mymalloc.o
```

### 2.2 链接时打桩

![image-20231225214206376](库打桩机制.assets/image-20231225214206376.png) 

![image-20231225214237426](库打桩机制.assets/image-20231225214237426.png) 

**文件结构：**

```
interpose/
├── int.c
├── makefile
└── mymalloc.c
```

文件：

```c
// int.c

#include<stdio.h>
#include<malloc.h>

int main()
{
    int *p = malloc(32);
    free(p);
    return 0;
}
```

```c
// mymalloc.c

#ifdef LINKTIME
#include<stdio.h>

void *__real_malloc(size_t size);
void __real_free(void *ptr);

//malloc 包装函数
void *__wrap_malloc(size_t size) {
    void *ptr = __real_malloc(size);  //Call libc malloc
    printf("malloc(%d)=%p\n", (int)size, ptr);
    return ptr;
}

//free 包装函数
void __wrap_free(void *ptr) {
    __real_free(ptr);  //Call libc free
    printf("free(%p)\n", ptr);
}
#endif
```

```makefile
# makefile

all:
	gcc -DLINKTIME -c mymalloc.c
	gcc -c int.c
	gcc -Wl,--wrap,malloc -Wl,--wrap,free -o intl int.o mymalloc.o
clean:
	rm intl mymalloc.o int.o
```

### 2.3 运行时打桩

![image-20231225221357428](库打桩机制.assets/image-20231225221357428.png) 

![image-20231225221455841](库打桩机制.assets/image-20231225221455841.png) 

**文件结构：**

```
interpose/
├── int.c
├── makefile
└── mymalloc.c
```

**文件：**

```c
// int.c

#include<stdio.h>
#include<malloc.h>

int main()
{
    int *p = malloc(32);
    free(p);
    return 0;
}
```

```c
// mymalloc.c


```

```makefile
# makefile


```

