# 哈夫曼树

## 1. 问题

## 2. 外部资料

b站视频：

https://www.bilibili.com/video/BV1kD4y1P76D/?spm_id_from=333.337.search-card.all.click&vd_source=c6838f09fbfc9766e04f0c65ca196c42



## 3. 基础知识

### 3.1 什么是哈夫曼树

哈夫曼树（Huffman Tree）又称最优二叉树，是一种带权路径长度最短的二叉树，也是一种应用广泛的二叉树。其特点是**权值较大的结点离根较近，而权值较小的结点离根较远。**树的带权路径长度记为WPL，即将所有叶子结点的带权路径长度求和，权值越大的结点越靠近根，树的带权路径长度就越小。

哈夫曼树的构造过程如下：

1. 根据给定的n个权值{w1,w2,…,wn}构成n棵二叉树的集合F={T1,T2,…,Tn}，其中每棵二叉树Ti中只有一个带权为wi的根结点，其左右子树均为空。
2. 在F中选取两棵根结点的权值最小的树作为左右子树构造一棵新的二叉树，且置新的二叉树的根结点的权值为其左右子树上根结点的权值之和。
3. 在F中删除这两棵树，同时将新得到的二叉树加入F中。
4. 重复上述操作，直到F中只剩下一棵二叉树为止。这棵树便是哈夫曼树。

哈夫曼树的应用非常广泛，主要用于数据压缩，通信中的编码、解码等。例如，在数据压缩中，我们可以将出现频率高的字符用较短的编码表示，而出现频率低的字符用较长的编码表示，从而达到压缩数据的目的。这种方法称为哈夫曼编码，是一种无损压缩方法。

此外，哈夫曼树还可以用于其他问题，如最优前缀码问题、判定问题等。在这些问题中，哈夫曼树都发挥了重要作用。

### 3.2 什么是哈夫曼编码

哈夫曼编码（Huffman Coding）是一种基于字符出现概率的可变长度前缀编码方法，由美国计算机科学家戴维·A·哈夫曼在1952年提出。该编码算法主要应用于数据压缩领域，通过构建最优二叉树（也称为哈夫曼树或最小带权路径长度树）来实现对原始数据中不同符号的高效编码。

**基本思想**：
- 对于一个给定的数据集，每个字符或符号都有其对应的出现频率。
- 哈夫曼编码的原则是将高频出现的符号用较短的编码表示，而低频出现的符号用较长的编码表示，从而使得整个编码系统能以最少的平均比特数来表示原数据集。
- 实现过程：首先根据频率构建哈夫曼树，即每次选取频率最低的两个节点合并生成新的父节点，并以其子节点的频率之和作为新节点的频率，重复此过程直至所有节点合并成一棵树。
- 从这棵树中自底向上构造编码，左分支代表0，右分支代表1，到达每个叶子节点时形成的编码路径即为该叶子节点对应符号的哈夫曼编码。

**特点**：
- **哈夫曼编码是无前缀编码，即任一编码都不是其他编码的前缀**，这确保了编码的唯一解码性。
- 因为它是可变长度编码，所以它比固定长度编码（如ASCII编码）在处理具有不平衡频率分布的数据时更加高效，可以显著减少存储空间。

**应用**：

- 数据压缩：文本文件、音频文件、视频文件等都可以使用哈夫曼编码进行压缩。
- 文件格式：许多文件格式中都采用类似哈夫曼编码的技术，如JPEG图像格式中的DCT系数编码、DEFLATE算法（用于ZIP和PNG文件格式）等。

## 4. 代码

```c++
#include<iostream>
#include<vector>
#include<queue>
#include<map>
#include<string>
#include<sstream>

using namespace std;

//哈夫曼树的节点结构体
struct Node {
    char ch;  //字符
    int weight;  //权值
    Node* left;  //左子树
    Node* right; //右子树
    Node(char c, int w, Node* l = nullptr, Node* r = nullptr)
        :ch(c), weight(w), left(l), right(r) { }
};

//比较函数，用于优先队列中的排序
struct Compare {
    bool operator()(const Node* l, const Node* r) {
        return l->weight > r->weight;  //最小堆，权值小的优先级高
    }
};

//哈夫曼类
class HuffmanTree {
public:
    HuffmanTree(): root(nullptr) {}
    ~HuffmanTree() {
        clear(root);
    }

    //构建哈夫曼树
    Node* build_huffmantree(const map<char, int> huff_data_map) {
        priority_queue<Node*, vector<Node*>, Compare> minheap_pq;  //最小堆优先队列
        for(auto& data : huff_data_map) {
            minheap_pq.push(new Node(data.first, data.second));
        }
        //当优先队列中还有多于一个节点时，继续构建树
        while(minheap_pq.size() > 1) {
            Node* left = minheap_pq.top();  //取出权值最小的节点作为左子树
            minheap_pq.pop();
            Node* right = minheap_pq.top(); //取出下一个权值最小的节点作为右子树
            minheap_pq.pop();
            int sum = left->weight + right->weight;
            minheap_pq.push(new Node(0, sum, left, right)); //0代表这是一个非叶子节点
        }
        Node* root = minheap_pq.top();
        minheap_pq.pop();
        return root;
    }

    //生成哈夫曼编码(前缀编码)
    void generate_huffmancodes(Node* root, string code, map<char, string>& huffman_codes_map) const {
        if(root == nullptr) {
            return;
        }
        if(root->ch != 0) {  //非叶子节点
            huffman_codes_map[root->ch] = code;
        }
        else { //叶子节点
            generate_huffmancodes(root->left, code + "0", huffman_codes_map);
            generate_huffmancodes(root->right, code + "1", huffman_codes_map);
        }
    }

    //释放内存，防止内存泄漏
    void clear(Node* root) {
        if(root == nullptr) {
            return;
        }
        clear(root->left);
        clear(root->right);
        delete root;
        root = nullptr;  //防止悬挂指针问题
        cout<<"destructure....\n";
    }
public:
    Node* root;  //哈夫曼树的根节点
};

int main()
{
    map<char, int> huff_data_map = {
        {'a', 5}, {'b', 9}, {'c', 12}, {'d', 13}, {'e', 16}, {'f', 45}
    };
    HuffmanTree* huffman_tree = new HuffmanTree();  //创建哈夫曼树对象
    huffman_tree->root = huffman_tree->build_huffmantree(huff_data_map); //构建哈夫曼树
    map<char, string> huffman_codes_map;  //用于存储哈夫曼编码的map
    huffman_tree->generate_huffmancodes(huffman_tree->root, "", huffman_codes_map);
    for(auto& data : huffman_codes_map) {
        cout<<data.first<<": "<<data.second<<endl;
    }

    //手动释放申请的内存
    delete huffman_tree;
}
```

