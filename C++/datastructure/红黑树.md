#  红黑树

## 1. 问题

## 2. 基础

### 2.1 外部资料

https://www.bilibili.com/video/BV1qG411a73p/?spm_id_from=333.999.0.0&vd_source=c6838f09fbfc9766e04f0c65ca196c42

### 2.2 基本定义

红黑树的节点要么是红色，要么是黑色。
红黑树是一种自平衡的二叉搜索树，具有如下3特性：

1. 根节点和所有外部节点（这里的外部节点，指NULL节点）都是黑色
2. 在根到外部节点的路径上，没有连续两个节点是红色
3. 在所有根到外部节点的路径上，黑色节点数目都相同

### 2.3 什么时候需要调整红黑树

当上面3条定义，有其中一条及以上不满足的时候就需要调整，通过调整将不满足红黑树定义的树，变成满足红黑树定义的树。

### 2.4 哪个最容易破坏

首先我们要讨论一个问题，在插入结点的时候，插入的结点颜色应该是红色还是黑色？

那我们就要想想，让新插入的结点是哪个颜色，最不容易破坏红黑树的三个定义？

**假设，我们插入的新节点颜色都是黑色。** 现在我们知道，在新结点插入之前，这棵树肯定是一棵红黑树，即肯定满足红黑树的3个定义。那也肯定满足定义3，即`在所有根到外部节点的路径上，黑色节点的数目都相同。` 好，那现在我们插入的新结点是黑色的，无论这个黑色节点在哪里，都会导致插入的那个结点到根节点的黑色节点数量比其他路径黑色节点多一个，也就是说，定义的第三个要求被破坏了。

**现在，我们再假设插入的新节点都是红色。** 同样的，插入红色节点前，这棵树是一棵红黑树。插入红色结点，会有两种情况：

1. 要插入的这个位置的父结点是红色，那定义第二点被破坏
2. 要插入这个位置的父节点是黑色，红黑树没有没破坏，不用调整

如果我们让插入的结点是黑色的，红黑树的结构一定被破坏，必然要进行树的调整。但是，如果我们让插入的所有结点都是红色的，那红黑树的结构有可能是不会被破坏的。所以，总体来说，让插入的所有结点都是红色，这样效率肯定会比让插入所有结点都是黑色效率要高。

## 3. 结点的插入

![image-20240102164621703](红黑树.assets/image-20240102164621703.png) 

### 3.1 插入结点整体分析

从上面的分析已经知道了，红黑树，所有插入的新结点都是红色的，所以，红黑树的插入会有这么几种情况。

- 插入前树空
  - 那么插入的这个结点就是根，根是黑色的，所以让这个结点是黑色的就行
- 插入位置的父结点是黑色
  - 正常插入，红黑树结构没有改变，不用调整
-  插入位置父结点是红色
  - **红黑树结构被改变，调整树**

### 3.2 红黑树被破坏的原因

前面两种情况都很好处理，核心是第三种情况。对于父节点是红色，对应的有那些小情况，这些小情况又该如何处理？

这里先简单脑补一下红色结点插入要调整的情况，以便我们对当前这个插入新结点的红黑树有更全面的认识。

![image-20240102164959503](红黑树.assets/image-20240102164959503.png) 



我们看上面这个图，虚线画的红色结点就是我们要插入的新结点，我们现在知道，其父节点是红色的，那么必然，其父节点不是根，因为，根是黑色。那么必然，其祖父节点是黑色的，因为，虚线红色节点插入进来以前，这个树是一个正常的红黑树。好知道了这些，我们继续往下看。

#### 3.2.1 LLb型失衡 

![image-20240102164959503](红黑树.assets/image-20240102164959503.png) 

这种情况被称为`LLb`型失衡，为什么这么把它叫这个名字呢`LLb`就是`left left black`的意思，我们来看为啥叫这个名字：

`LL(left left)`的解释：

+ 插入的红色结点，来自于当前最小不平衡子树的左子树`(left)`的左子树`(left)`

`b(black)`的解释：

+ 这个最小不平衡子树的右孩子结点（即插入结点的叔叔）为`b(black)`，当然，这个结点可以是黑色普通结点，也可以是NULL

#### 3.2.2 失衡归纳

![image-20240102165620595](红黑树.assets/image-20240102165620595.png) 

注意，这里的实线方框表示，还有别的节点，但是我们不关心。带虚线的方框表示NULL空节点，当然，空节点也是黑色节点。

ok,我们现在将所有插入所导致的失衡已经罗列出来了，一共8种情况，我在他们中间花了一条线，左边都是`XXb`以b结尾，即要插入结点的叔叔都是`black`。右边都是`XXr`这种格式的，以r结尾，即要插入的结点的叔叔都是`red`。

为什么要将其分开呢，因为，左边和右边的调整方案不一样，左边即`XXb`要通过旋转+变色就可以调整，右边`XXr`只通过改变颜色来处理就可以。

总结一下：

-  `XXr`->变色调整
  -  即，要插入结点的叔叔是红色，通过变色来调整
- `XXb`->旋转调整+变色
  - 即，要插入结点的叔叔是黑色，通过旋转来调整

### 3.3 对失衡的处理办法

#### 3.3.1 XXr:变色调整

我们这里以`LLr`和`LRr`举例子，`RRr`和`RLr`的方法是对称类似的。为了方便描述，我们将新插入的结点叫做u，那其父结点就是`parent u`即`pu`，其祖父结点就是`grand u`即`gu`。

![image-20240102170213664](红黑树.assets/image-20240102170213664.png) 



下面是修改方式的语言总结：

1. u的叔叔节点变为黑色
2. u的父亲节点变为黑色
3. u的祖父节点变为红色
4. u的祖父节点作为新的u进行向上层检查

ok,这样对于gu这个小子树来说就已经修改完毕了，但是有个问题，如果gu的父亲是红色的，那第二步经gu修改为红色以后，那岂不是又不平衡了，没关系，那我们将gu当做u，分析gu的父亲结点，祖父结点，再根据具体情况具体调整就行了。后面看代码会发现非常简单，一个while循环就搞定了。

同样的，我们通过上面的`LLr`和`LRr`可以发现他俩的调整情况是一样的。那同样`RRr`和`RLr`的调整情况也是一样的。所以，我们在具体代码实现的时候，颜色变换本质上就只有两种情况`LXr`和`RXr`。

#### 3.3.2 XXb:旋转+变色调整

ok，我们现在来说旋转。旋转对于LLb和LRb两种情况，RLb和RRb对称类似，逻辑对称，代码也对称。下面，我先来说LLb，然后再说LRb。为什么这么安排呢？因为，我们解决LRb的方案就是， 先把LRb转换为LLb，然后再对其进行处理。

##### 3.3.2.1 LLb

首先，LLb，回忆一下啥是LLb? 插入节点u的父节点是红色，u的祖父节点的另一个孩子，也就是u的叔叔是黑色，即为NULL。我们这里统一将叔叔节点称为y。然后，我们来看怎么处理，直接看图：

![image-20240102174002514](红黑树.assets/image-20240102174002514.png) 

具体流程，用语言描述如下：

1. u的父节点颜色变为黑色
2. u的祖父节点颜色变为红色
3. 对u的祖父gu为根的子树进行右旋

通过上面的流程我们能发现，这个子树，在经过旋转和变色以后，黑色节点数量没有变化，同时，也解决了两个红色节点的问题，所以，不需要在往这个子树的上面去检查了。

##### 3.3.2.2 LRb

下面我们来看LRb，LRb的解决思路就是，通过一次旋转，将LRb转化为LLb，然后，再按照处理LLb的方式处理LRb即可。

直接看图，看看如何将其LRb转换为LLb吧。

![image-20240102174219648](红黑树.assets/image-20240102174219648.png) 

下面用语言来简单描述下如何处理LRb情况：

1. 让u的父亲节点为u
2. 对u子树进行左旋（此时已经转换为LLb型）
3. 再进行LLb型处理
   1. u的父亲节点颜色变为黑色
   2. u的祖父节点颜色变为红色
   3. 对u的祖父节点gu为根的子树进行右旋

同样的，经过上面的操作以后，处理过的这个子树中黑色节点的数量没有发生改变，所以不需要去向上进行检查。

## 4. 代码

[rbtree.c](https://github.com/niu0217/Documents/blob/main/C%2B%2B/datastructure/code/rbtree.c)

```c
#include<stdio.h>
#include<stdlib.h>

#define RED 1
#define BLACK 2
typedef int KEY_TYPE;

//定义红黑树节点的结构体
typedef struct _rbtree_node {
    unsigned char color;  //红色是1；黑色是2
    struct _rbtree_node* left;
    struct _rbtree_node* right;
    struct _rbtree_node* parent;
    KEY_TYPE key;
    void* value;  //用不到
}rbtree_node;

//定义红黑树
typedef struct _rbtree {
    rbtree_node* root;  //根指针
    rbtree_node* nil;  //外部指针
}rbtree;

//生成一个新的节点，并赋初值
rbtree_node* new_node(rbtree* T, int key) {
    rbtree_node* node = (rbtree_node*)malloc(sizeof(rbtree_node));
    node->color = RED; //新节点的最初颜色都是红色
    node->key = key;
    node->value = NULL;
    node->left = T->nil;
    node->right = T->nil;
    node->parent = T->nil;
    return node;
}

//左旋：
//  1.当前结点的右子树会作为新树的根结点
//  2.当前结点会作为新树的根结点的左子树
//  3.如果，新的树根，原来有左子树，原来的左子树，就作为旧根结点的右子树
void left_rotate(rbtree* T, rbtree_node* root) {
    rbtree_node* new_root = root->right;  //对应步骤1
    rbtree_node* root_rl = root->right->left;  //保存当前结点的右子树的左子树结点
    root->right = root_rl;  //对应步骤3

    //修改父结点
    //一共三个结点的父结点改变了：root_rl、new_root、root
    //修改root_rl的父结点
    if(root_rl != T->nil) {
        root_rl->parent = root;
    }
    //修改new_root的父结点
    new_root->parent = root->parent;
    if(root->parent == T->nil) {
        //说明，原来的root，就是整个树的根
        T->root = new_root;
    }
    else if(root == root->parent->left) {
        root->parent->left = new_root;
    }
    else if(root == root->parent->right) {
        root->parent->right = new_root;
    }
    //修改root的父结点
    new_root->left = root;  //对应步骤2
    root->parent = new_root;
}

//右旋：
//  1.当前结点的左子树会作为新树的根结点
//  2.当前结点会作为新树的根结点的右子树
//  3.如果，新的树根，原来有右子树，原来的右子树，就作为就根结点的左子树
void right_rotate(rbtree* T, rbtree_node* root) {
    rbtree_node* new_root = root->left;  //对应步骤1
    rbtree_node* root_lr = root->left->right;  //保存当前结点的左子树的右子树结点
    root->left = root_lr;  //对应步骤3

    //修改父结点
    //一共三个结点的父结点改变了：root_lr、new_root、root
    //修改root_lr的父结点
    if(root_lr != T->nil) {
        root_lr->parent = root;
    }
    //修改new_root的父结点
    new_root->parent = root->parent;
    if(root->parent == T->nil) {
        //说明，原来的root，就是整个树的根
        T->root = new_root;
    }
    else if(root == root->parent->left) {
        root->parent->left = new_root;
    }
    else if(root == root->parent->right) {
        root->parent->right = new_root;
    }
    //修改root的父结点
    new_root->right = root;  //对应步骤2
    root->parent = new_root;

}

//调整插入结点后的红黑树，避免失衡
void rbtree_insert_fixup(rbtree* T, rbtree_node* u) {
    while(u->parent->color == RED) {
        if(u->parent == u->parent->parent->left) {
            //LXx
            //获取插入结点的叔叔结点
            rbtree_node* y = u->parent->parent->right;
            if(y->color == RED) {
                //LXr
                //1.u的父亲结点变为黑色
                //2.u的叔叔结点变为黑色
                //3.u的祖父结点变为红色
                //4.将u更新为u的祖父结点，继续向上检查
                u->parent->color = BLACK;
                y->color = BLACK;
                u->parent->parent->color = BLACK;
                u = u->parent->parent;
            }
            else if(y->color == BLACK) {
                if(u == u->parent->right) {
                    //LRb
                    //1.先转换为LLb型
                    //  1.pu更新为u
                    //  2.对u子树进行左旋
                    //2.u的父亲结点变为黑色
                    //3.u的祖父结点变为红色
                    //4.对u的祖父结点为根的子树进行右旋
                    u = u->parent;
                    left_rotate(T, u);
                }
                //LLb
                //1.u的父亲结点变为黑色
                //2.u的祖父结点变为红色
                //3.对u的祖父结点为根的子树进行右旋
                u->parent->color = BLACK;
                u->parent->parent->color = RED;
                right_rotate(T, u->parent->parent);
            }
        }
        else if(u->parent == u->parent->parent->right) {
            //RXx
            //获取插入结点的叔叔结点
            rbtree_node* y = u->parent->parent->left;
            if(y->color == RED) {
                //RXr
                //1.u的父亲结点变为黑色
                //2.u的叔叔结点变为黑色
                //3.u的祖父结点变为红色
                //4.将u更新为u的祖父结点，继续向上检查
                u->parent->color = BLACK;
                y->color = BLACK;
                u->parent->parent->color = RED;
                u = u->parent->parent;
            }
            else if(y->color == BLACK) {
                if(u == u->parent->left) {
                    //RLb
                    //1.先转换为RRb型
                    //  1.pu更新为u
                    //  2.对u子树进行右旋
                    //2.u的父亲结点变为黑色
                    //3.u的祖父结点变为红色
                    //4.对u的祖父结点为根的子树进行右旋
                    u = u->parent;
                    right_rotate(T, u);
                }
                //RRb
                //1.u的父亲结点变为黑色
                //2.u的祖父结点变为红色
                //3.对u的祖父结点为根的子树进行左旋
                u->parent->color = BLACK;
                u->parent->parent->color = RED;
                left_rotate(T, u->parent->parent);
            }
        }
    }
    T->root->color = BLACK;
}

//插入新结点
void rbtree_insert(rbtree* T, rbtree_node* z) {
    rbtree_node* y = T->nil;
    rbtree_node* x = T->root;
    while(x != T->nil) {
        y = x;  //y保存的是插入结点的父结点
        if(z->key < x->key) {
            x = x->left;  //在左子树中查找
        }
        else if(z->key > x->key) {
            x = x->right;  //在右子树中查找
        }
        else {
            return;  //不允许插入两个值相同的结点
        }
    }

    //找到z的父结点
    z->parent = y;
    //找到z应该插入的位置
    if(y == T->nil) {
        //如果要插入这个位置的父结点是空，则说明是根结点
        T->root = z;
    }
    else if(z->key < y->key) {
        y->left = z;
    }
    else if(z->key > y->key) {
        y->right = z;
    }

    //调整红黑树
    rbtree_insert_fixup(T, z);
}

//中序遍历
void mid_traversal(rbtree* T, rbtree_node* node) {
    if(node == T->nil) {
        return;
    }
    mid_traversal(T, node->left);
    printf("key:%d, color:%d\n", node->key, node->color);
    mid_traversal(T, node->right);
}

//先序遍历
void pre_traversal(rbtree* T, rbtree_node* node) {
    if(node == T->nil) {
        return;
    }
    printf("key:%d, color:%d\n", node->key, node->color);
    pre_traversal(T, node->left);
    pre_traversal(T, node->right);
}

int main()
{
    //10,50,60,62,65,70
    int key_array[6] = {10, 50, 60, 62, 65, 70};
    //创建一个红黑树
    rbtree* T = (rbtree*)malloc(sizeof(rbtree));
    //定义外部结点（NULL）
    T->nil = (rbtree_node*)malloc(sizeof(rbtree_node));
    T->nil->color = BLACK;
    T->root = T->nil;
    //红黑树插入结点
    rbtree_node* node = T->nil;
    for(int i = 0; i < 6; i++) {
        node = new_node(T, key_array[i]);
        rbtree_insert(T, node);
    }
    //打印插入的结点的结果
    printf("-----------------------中序遍历---------------------\n");
    mid_traversal(T, T->root);
    printf("-----------------------先序遍历---------------------\n");
    pre_traversal(T, T->root);
}
```

![image-20240102222106290](红黑树.assets/image-20240102222106290.png) 

