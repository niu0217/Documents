# 正则表达式

## 1. 两个网站和总结

### 1.1 两个网站

+ 正则练习网址： https://www.codejiaonang.com/
+ 正则在线测试网站： https://regexr-cn.com/

### 1.2 总结

| 实例          | 描述                                |
| ------------- | ----------------------------------- |
| `[Pp]ython`   | 匹配 “Python” 或 “python”。         |
| `rub[ye]`     | 匹配 “ruby” 或 “rube”。             |
| `[abcdef]`    | 匹配中括号内的任意一个字母。        |
| `[0-9]`       | 匹配任何数字。类似于 [0123456789]。 |
| `[a-z]`       | 匹配任何小写字母。                  |
| `[A-Z]`       | 匹配任何大写字母。                  |
| `[a-zA-Z0-9]` | 匹配任何字母及数字。                |
| `[^au]`       | 除了au字母以外的所有字符。          |
| `[^0-9]`      | 匹配除了数字外的字符。              |

| RE 字符    | 意义和范例                                                   |
| ---------- | ------------------------------------------------------------ |
| `.`        | 意义：代表【一定有一个任意字符】的字符，换行符除外；<br/>举例：e与e的中间【一定】仅有一个字符，空格符也是字符；<br/>`grep -n 'e.e' regular_express.txt` |
| `*`        | 意义：重复0个或无穷多个的前一个RE字符；<br/>举例：查找`es ess esss`等的字符串；<br/>`grep -n 'ess*' regular_express.txt` |
| `.*`       | `.`和`*`组合起来的。非常重要！！<br/>`.`代表任意字符。`*`代表重复前一个字符，0次或多次。因此`.*`就是重复任意字符，0次或多次<br/>举例：g开头和g结尾，中间任意个字符的字符串；<br/>`grep -n 'g.*g' regular_express.txt`<br>注意事项：`.*`不能匹配`\n`，遇到换行符自动结束。 |
| `.*?`      | 意义：【非贪婪模式】匹配，最短匹配原则。                     |
| `?`        | 意义：【零个或一个】的前一个RE字符；<br/>举例：查找`gd god`这个两个字符串，`o?`表示【空的或1个o】；<br/>`egrep -n 'go?d' regular_express.txt` |
| `+`        | 意义：重复【一个或一个以上】的前一个RE字符；<br/>举例：查找`god good gooood`等字符串，`o+`代表【一个以上的o】；<br/>`egrep -n 'go+d' regular_express.txt` |
| `\`        | 意义：转义符，【将特殊符号的特殊意义去除】；<br>举例：查找含有单引号`'`的那一行；<br>`grep -n \' regular_express.txt` |
| `|`        | 意义：用或（or）的方式找出数个字符；<br>`egrep -n 'gd|good' regular_express.txt`<br>`egrep -n 'gd|good|dog' regular_express.txt` |
| `()`       | 意义：找出【群组】字符串；<br>举例：`egrep -n 'g(la|oo)d' regular_express.txt` |
| `()+`      | 意义：多个重复群组的判别；<br>举例：`echo 'AxyzxyzxyzxyzC' | egrep 'A(xyz)+C'`；<br>含义：查找开头是A，结尾是C，中间有一个以上的“xyz”字符串 |
| `^word`    | 意义：待查找的字符串word在行首；<br>举例：查找行首为`#`开始的那一行，并列出行号；<br>`grep -n '^#' regular_express.txt` |
| `word$`    | 意义：待查找的字符串word在行尾；<br>举例：将行尾为`!`的那一行打印出来，并列出行号；<br>`grep -n '!$' regular_express.txt` |
| `[list]`   | 意义：字符集合的RE字符，里面列出想要选取的【字符】；<br>举例：`grep -n 'g[ld]' regular_express.txt` |
| `[n1-n2]`  | 意义：字符集合的RE字符，里面列出想要选取的【字符范围】；<br>举例：`grep -n '[A-Z]' regular_express.txt` |
| `[^list]`  | 意义：字符集合的RE字符，里面列出不要的【字符串或范围】；<br>举例：`grep -n 'oo[^t]' regular_express.txt` |
| `\{n,m\}`  | 意义：连续n到m个的【前一个RE字符】；<br>意义：若为`\{n\}`，则是连续n个的【前一个RE字符】；<br>意义：若为`\{n,\}`，则是连续n个以上的【前一个RE字符】；<br>举例：`grep -n 'go\{2,3\}g' regular_express.txt` |
| `\{n,m\}?` | 意义：连续n到m个的【前一个RE字符】，非贪心匹配。默认是贪心匹配，加了`?`就是非贪心；<br>举例：`r'(Ha){3, 5}'`，如果输入`HaHaHaHaHa`，则匹配的结果就是`HaHaHaHaHa`，因为默认是贪心匹配，<br>最长匹配原则。但是如果后面加个`?`，`r'(Ha){3, 5}?'`，这个时候是非贪心匹配，最短匹配原则，匹配的是`HaHaHa` |
| `\b`       | 匹配长度为`0`的子串                                          |
| `\d`       | 匹配数字字符。等价于` [0-9]`。                               |
| `\D`       | 匹配非数字字符。                                             |
| `\s`       | 匹配任何空白字符，包括空格、制表符、换页符等等。等价于` [ \f\n\r\t\v]`。 |
| `\S`       | 匹配任何非空白字符。                                         |
| `\w`       | 匹配包括下划线的任何单词字符。等价于`[A-Za-z0-9_]`。不包括空格。 |
| `\W`       | 匹配任何非单词字符。                                         |

## 2. 正则表达式入门

### 2.1 匹配2020的数据

```
需要匹配的
  2010—2020年
  2020年1月25日
  2020年2月11日
  2020年闰四月
  2020是闰年
  
不能匹配的
  2023
  1998
  相约98
  2008奥运会
  1978
```

```react
2020
```

### 2.2 字符组

```
需要匹配的
  Java8.0
  java8.0

不能匹配的
  jjva
  Javv
```

```react
[Jj]ava
```

### 2.3 匹配多个单词

```
需要匹配的
  ruby
  rube
  Ruby on Rails
  Rube on Rails

不能匹配的
  rubb on rails
  ruyye on rails
  ruee
  hello world
```

```react
[Rr]ub[ye]
```

### 2.4 区间

```
需要匹配的
  abcdefg
  012345678
  987654321
  ABCDEFG
  
不能匹配的
  +_)*^$%
  <>?:"{}
  （）。，/
  ?><,.>()
```

```react
[a-zA-Z0-9]
```

### 2.5 匹配特殊字符

```
需要匹配的
  []
  -----
  --
  ()
不能匹配的
  123456789
  Abcdefg
  code123
  0codejn
```

```react
[\[\]\-\(\)]
```

### 2.6 匹配字母

```
需要匹配的
  a
  b
  y
  z
  B
  A
  F
  
不能匹配的
  0
  01
  012
  []()\
  Q0123456789---
  0123456789
  .-/*130.
```

```react
[a-zA-F]
```

### 2.7 匹配目标数据

```
需要匹配的
  abc01
  ddd02
  afcf01
  acac11
  321
  acef33
  bbc000

不能匹配的
  ABCDEFG789654
  CODEJIAONANG
  ghjkloiqwtq
  poiuy98765
  msstgr4567
  gg8888888
  88888888999
```

```react
[a-f0-3]
```

### 2.8 取反

```
需要匹配的
  爱吗
  爱哦
  爱我自己
  爱了
  我爱我

不能匹配的
  我爱你
  爱你
  爱你爱你
  不爱你
  爱你一万年
```

```
爱[^你]
```

### 2.9 不含小写字母的数据

```
需要匹配的
  01234
  1234567890
  ABCDEFG
  CODEJIAONANG123
  []
  +_)(91283)
  -*/124566ABV

不能匹配的
  ab
  abc
  abcd
  www
  codejiaonang
  com
  pythonregext
```

```react
[^a-z]
```

### 2.10 快捷匹配数字和字母

正则表达式引擎提供了一些快捷方式如：`\w` 可以与**任意单词字符**匹配。

当我们想要**匹配任意数字**的时候也可以使用快捷方式`\d`，`d`即`digit`数字的意思，等价于`[0-9]`。

| 快捷方式 | 描述                                                         |
| -------- | ------------------------------------------------------------ |
| \w       | 与任意单词字符匹配，任意单词字符表示 `[A-Z]`、 `[a-z]`、`[0-9]`、`_` |
| \d       | 与任意数字匹配                                               |

```
需要匹配的
  master
  code
  jiaonang
  123456789
  987654321
  0123
  CODE
  JIAONANG
  hello world
  python
  
不能匹配的
  //\
  =-
  /*-
  `
  !!!
  $#$%
  /*-+
  <>()
  {}
  ||
```

```react
\w
```

### 2.11 匹配空白

`\s`快捷方式可以**匹配空白字符**，比如空格，tab、换行等。

```
需要匹配的
  code
  code jiaonang
  code jiaonang
  code www
  code jiaonang
  
不能匹配的
  CODEINFO
  codeasd/
  codejiaonangA$
  JIAONANG-MASTER
  CO DEJIAONANG!
```

```react
code\s
```

### 2.12 单词边界

`\b` 匹配的是单词的边界

`\bmaster\b` 就仅匹配有边界的`master`单词。

```
需要匹配的
  code
  code jiaonang
  code.jiaonang
  www.code
  code-jiaonang
  
不能匹配的
  CODEINFO
  codeasd/
  codejiaonangA$
  JIAONANG-MASTER
  CODEJIAONANG!
```

```react
code\b
```

### 2.13 匹配数字和小写字母

```
需要匹配的
  co
  de
  jiao
  nang
  12
  21
  33
  42
  
不能匹配的
  CODEINFO
  HEHE.,/
  $HAHA$
  $￥%^&*
  []()*()_+
  CODEJIAONANG!
  JIAONANG-MASTER
  DJANGO-PYTHON
```

```react
[\da-z]
```

### 2.14 快捷方式取反

快捷方式也可以取反，例如对于`\w`的取反为`\W`，将小写改写成大写即可，其他快捷方式也遵循这个规则。

```
需要匹配的
  ￥master
  $codejiaonang
  ()helloworld
  +python
  -java
  *ruby
  
不能匹配的
  master
  code
  python
  java
  ruby
  regex
```

```react
\W
```

### 2.15 开始和结束

正则表达式中 `^`指定的是一个字符串的开始，`$`指定的是一个字符串的结束。

```
需要匹配的
  windows OS
  Mac OS
  LinuxOS
  AppleOS

不能匹配的
  OSopen
  apple os
  windows os
  OSx
```

```react
OS$
```

### 2.16 任意字符

`.`字符代表匹配任何单个字符，它**只能出现在方括号以外**。

**值得注意的是：** `.`字符只有一个不能匹配的字符，也就是换行符（`\n`），不过要让`.`字符与换行符匹配也是可以的，以后会讨论。

```
需要匹配的
  ear
  car
  parked
  garage
  barked
  rar
  haarr
  
不能匹配的
  in the
  ar
  aer
  acer
  ha ha
  anr
  and
```

```react
.ar
```

### 2.17 可选字符

有时，我们可能想要匹配一个单词的不同写法，比如`color`和`colour`，或者`honor`与`honour`。

这个时候我们可以使用 `?` 符号指定一个字符、字符组或其他基本单元可选，这意味着正则表达式引擎将会期望该字符出现**零次或一次**。

```
需要匹配的
  favorite
  favourite
  favorite
  favourite
  
不能匹配的
  favo
  favrite
  favouite
  urite
```

```react
favou?rite
```

### 2.18 可选任意字符

```
需要匹配的
  codejiaonang
  code.jiaonang
  code-jiaonang
  (code)jiaonang
  code(jiaonang)
  code jiaonang
  	
不能匹配的
  codeabjiaonang
  codjiaonang
  asdd21333121mn
  asdiouiqweuhhk
  codjiaonang
  jiaonangcode
```

```react
code.?jiaonang
```

### 2.19 重复

在一个字符组后加上`{N}` 就可以表示在它之前的字符组出现`N`次。

```
需要匹配的
  010-88480
  020-72813
  030-12345
  020-66666
  030-98788
  030-88888
  
不能匹配的
  123-123
  01-72813
  0-12345
  20-66666
  0-98788
  0--808888
```

```react
\d{3}-\d{5}
```

### 2.20 重复区间

可能有时候，我们不知道具体要匹配字符组要重复的次数，比如身份证有`15`位也有`18`位的。

这里重复区间就可以出场了，语法：`{M,N}`，`M`是下界而`N`是上界。

```
需要匹配的
  020-7281333
  010-8281333
  221-6549451
  0733-8845632
  221-6549451
  010-5214567
  0733-8845632
  0731-4485855
  
不能匹配的
  123
  221-654945
  1234567
  02asd311321
  0715-45678
  010-7789
  02311321
  123456789
```

```react
\d{3,4}-\d{7}
```

### 2.21 开闭区间

可以使用两个速写字符指定常见的重复情况，可以使用 `+` 匹配`1`个到无数个，使用 `*`代表`0`个到无数个。

即：`+`等价于`{1,}`，`*`等价于`{0,}`。

```
需要匹配的
  f0asd...a123---
  food
  father
  faker
  fooder
  fufufu
  
不能匹配的
  f
  brather
  brathef
  arathef
  codejiaonang
  mastercode
```

```react
f.+
```

### 2.22 匹配所有手机号

现在请你使用正则表达式匹配手机号码，假设手机号码规则如下：

- 必须是`11`位的数字；
- 第一位数字必须以`1`开头，第二位数字可以是`[3,4,5,7,8]`中的任意一个，后面`9`个数是`[0-9]`中的任意一个数字。

```
需要匹配的
  18111234589
  18711001111
  13713201111
  13712345678
  14712345897
  15721565489
  17721565489
  
不能匹配的
  29711001111
  30711001111
  41711001111
  58-1110011110
  68711001111
  12345678911
  200110023057123
```

```react
^1[3,4,5,7,8]\d{9}
```

### 2.23 匹配网站地址

请编写正则表达式，匹配以 `http`开头，以`/`结尾的所有数据。

```
需要匹配的
  https://code.com/
  http://codejn/
  http://google.com/
  https://codejn/
  https://google.com/

不能匹配的
  google.com
  http
  codeinfo/
  master/
  http:jn/code
```

```react
^http.*/$
```

### 2.24 匹配以fu结尾的数据

```
需要匹配的
  toufu
  fu
  snafu
  kongfu
  fufufu
  fu-fu
  afu
  
不能匹配的
  futz
  fusillade
  functional
  fude
  cfuinfo
  sufuf
  wofule
```

```react
fu$
```

### 2.25 匹配电话号码

匹配电话号码，假设电话号码可以有下列两种方式：

- 0XX-XXXXXXX，例如`020-8810456`；
- 0XXXXXXXXX，例如`0208810456`。

`020` 代表区号，`8810456`是电话号码，区号**第一个数字必须是**`0`，电话号码的**第一个数字必须大于等于1**。

```
需要匹配的
  010-7810456
  020-8810456
  030-1810456
  0208810456
  0107810456
  0107811356
  
不能匹配的
  020-88104XX
  01007214569
  3208810456
  010-08104560
  010-0810456
  120-8810456
```

```react
^0\d{2}[-]?[1-9]\d{6}
```

### 2.26 匹配所有王姓同学的信息

```
需要匹配的
  王敏 0001
  王磊 1234
  王静 0102
  王丽 0502
  王秀英 0503
  王芳芳 0503
  
不能匹配的
  王芳 04
  李秀英 0586
  李娜 0504
  大王 0505
  刘伟 1729
  张敏 1377
```

```react
^王\S+\s+\d{4}
```

## 3. 正则表达式进阶

### 3.1 分组

#### 3.1.1 分组

 在正则表达式中还提供了一种将表达式**分组**的机制，当使用分组时，除了获得整个匹配。还能够在匹配中选择每一个分组。

要实现分组很简单，使用`()`即可。

```react
(\d{4})-(\d{7})

# 张三：0731-8825921
```

这段正则表达式将文本**分成了两组**，第一组为：`0731`，第二组为`8825951`。

分组有一个非常重要的功能——`捕获数据`。所以`()`被称为捕获分组，用来捕获数据，当我们想要从匹配好的数据中提取关键数据的时候可以使用分组。

`(\d{4})` 和 `(\d{7})`就分别捕获了两段数据：

1. `0731`
2. `8825951`

```
需要匹配的
  <div>hi</div>
  
需要提取的
  hi
```

```react
<div>(.*)</div>
```

#### 3.1.2 提取p标签中的数据

请你使用分组提取`<p>` `</p>`中的数据

```
需要匹配的
  <p>hello</p>
  <p>word</p>
  <p>code</p>
  <p>jiaonang</p>
  
需要提取的
  hello
  word
  code
  jiaonang
```

```react
<p>(.+)</p>
```

#### 3.1.3 提取学号

有些学校的学号是由多个关键信息组成的，例如：`2019-5013-08` `2019`表示入学年份，`5013`表示班级代码，`08`表示班级中的排序。

接下来请你编写正则表达式匹配不同格式的学号，并将其中的关键信息用分组提取出来，需要分成三个分组。

```
需要匹配的
  2019-5013-08
  2019 5013 08
  2019501308
  
需要提取的
  2019 5013 08
  2019 5013 08
  2019 5013 08
```

```react
(\d{4})[\-\s]?(\d{4})[\-\s]?(\d{2})	
```

```react
(\d{4})[\s-]?(\d{4})[\s-]?(\d{2})
```

#### 3.1.4 提取年月日

```
需要匹配的
  2020-1-2
  2020-2-2
  2020-01-02
  2020/01/20
  
需要提取的
  2020 1 2
  2020 2 2
  2020 01 02
  2020 01 20
```

```react
(\d{4})[\-/\s]?(\d{1,2})[\-/\s]?(\d{1,2})
```

#### 3.1.5 或者条件

使用分组的同时还可以使用 **或者**（`or`）条件。

例如要提取所有图片文件的后缀名，可以在各个后缀名之间加上一个 `|`符号：

视频文件的后缀名有 `.mp4`、`.avi`、`.wmv`、`.rmvb`

请编写正则表达式提取所有的视频文件的后缀

```
需要匹配的
  1.avi
  abc.mp4
  chapter1.wmv
  chapter2.rmvb
  
需要提取的
  .avi
  .mp4
  .wmv
  .rmvb
```

```react
(.avi|.mp4|.wmv|.rmvb)
```

#### 3.1.6 非捕获分组

有时候，我们并不需要捕获某个分组的内容，但是又想使用分组的特性。

这个时候就可以使用非捕获组`(?:表达式)`，从而**不捕获数据**，还能使用分组的功能。

例如想要匹配**两个字母组成的单词**或者**四个字母组成的单词**就可以使用**非捕获分组**：

```
需要匹配的
  01-75855
  0731-75855
  12345-75855
  tel:75855

需要提取的
  75855
  75855
  75855
  75855
```

```react
(?:\d{2,}|tel:)[\-]?(\d+)
```

#### 3.1.7 分组使用技巧

接下来请提取所有年月日的数据

> 注意：因为正则表达式中`()`代表分组，所以如果要匹配`()`就需要将使用转义符`\`，例如要匹配`)`就要写成 `\)`。

```
需要匹配的
  2020-01-02
  2020-1-2
  2020.01.02
  2020 01 02
  2020 1 2
  20200102
  2020/01/02

需要提取的
  2020 01 02
  2020 1 2
  2020 01 02
  2020 01 02
  2020 1 2
  2020 01 02
  2020 01 02
```

```react
(\d{4})[\-/ .]?(\d{1,2})[\-/ .]?(\d{1,2})
```

#### 3.1.8 提取所有电话号码

```
需要匹配的
  2118673676
  (211)8673676
  211.867.3676
  (211)867-3676
  211-867-3676

需要提取的
  211 867 3676
  211 867 3676
  211 867 3676
  211 867 3676
  211 867 3676
```

```react
\(?(\d{3})[\-\.)]?(\d{3})[\-\.)]?(\d{4})
```

#### 3.1.9 分组的回溯引用

```
<font>提示</font>

<(\w+)>(.*?)</\1>
```

```
需要匹配的
  abccba
  allagmatic
  otto
  abba
  asffs
  maam
  warrandice
  
不能匹配的
  aaruria
  bluted
  cffusive
  dusoid
  eesthophysiology
  fmphimictical
  ccritan
```

```react
(\w)(\w)\2\1
```

#### 3.1.10 回溯引用实践

```
需要匹配的
  mama
  baba
  froufrou
  barbar
  haha
  hehe
  ohhohh
  
不能匹配的
  abcd
  abba
  gummage
  asdhweuir
  babb
  aa
  ccbbdd
```

```react
(\w{2,})\1
```

### 3.2 先行断言

#### 3.2.1 正向先行断言

很多人也称先行断言和后行断言为**环视**，也有人叫**预搜索**，其实叫什么无所谓，重要的是知道如何使用它们！

先行断言和后行断言总共有四种：

1. 正向先行断言
2. 反向先行断言
3. 正向后行断言
4. 反向后行断言

**正向先行断言：**`(?=表达式)`，指在某个位置向右看，表示所在位置右侧必须能匹配`表达式`

例如：

```
我喜欢你 我喜欢 我喜欢我 喜欢 喜欢你
```

如果要取出**喜欢**两个字，要求这个**喜欢**后面有你，这个时候就要这么写：`喜欢(?=你)`，这就是**正向先行断言**。

现在请你编写正则表达式进行密码强度的验证，规则如下：

- 至少一个大写字母
- 至少一个小写字母
- 至少一个数字
- 至少`8`个字符

左边为需要你的正则需要匹配的，右边的字符串是你的正则不需要匹配的。

```
需要匹配的
  Admin123456
  pZUJLUpTL2
  Tnut2eWPN1
  wJxpVhVYi3
  UySRo49ps
  Ig7AHzZ0J
  oYHMDdHCK9
  yiyWKQnWo2
  gTZEEkVrj1
  8Ij12340as
  wdfqe#wefDdf444
  Codejiaonang123
  CodeJiaonang@qq1
  111111abc11ABc
  CodeJiaonang123
  
不能匹配的
  qwe
  8848
  123456
  asd123
  Adm123
  Asd123
  wjleif932
  admin123
  123admin
  123asd123
  ADMIN123()
  编号89757
  888888888info
  masterxiao123
  888888888A
```

```react
(?=.*?[A-Z])(?=.*?[a-z])(?=.*?[0-9]).{8,}
```

#### 3.2.2 反向先行断言

**反向先行断言**`(?!表达式)`的作用是保证右边不能出现某字符。

例如： `我喜欢你 我喜欢 我喜欢我 喜欢 喜欢你`

如果要取出**喜欢**两个字，要求这个**喜欢**后面没有你，这个时候就要这么写：`喜欢(?!你)`，这就是**反向先行断言**。

```
需要匹配的
  abc@sina.com
  qq@163.com
  a@google.com
  qq@123.com

不能匹配的
  test@qq.com
  qq@qq.com
  gc@qq.com
  163@qq.com
```

```react
@(?!qq)
```

#### 3.2.3 匹配标签

编写正则表达式匹配除`<p>`或`</p>`之外的所有标签。

```
需要匹配的
  <div></div>
  <h1></h1>
  <h2></h2>
  <h3></h3>
  <h4></h4>
  <h5></h5>
  <tr></tr>
  <td></td>

不能匹配的
  <p></p>
  <p>code</p>
  <p></p><p></p>
  <p></p><p></p>
  <p></p><p></p>
  <p></p><p></p>
  <p></p><p></p>
  <p></p><p>
```

```react
<(?!p).+></(?!p).+>
```

### 3.3 后行断言

#### 3.3.1 正向后行断言

本小节只需要你记住一句话：先行断言和后行断言只有一个区别，即**先行断言从左往右看，后行断言从右往左看。**

**正向后行断言：**`(?<=表达式)`，指在某个位置向左看，表示所在位置左侧必须能匹配`表达式`

例如：如果要取出喜欢两个字，要求喜欢的**前面有我**，**后面有你**，这个时候就要这么写：`(?<=我)喜欢(?=你)`。

使用正则表达式匹配匹配王姓同学的名字。

```
需要匹配的
  王芳
  王芳芳
  芳芳 王菲
  菲菲 王菲菲
  王五
  
不能匹配的
  张三
  李四 小王
  富贵
  二麻子
  大王
```

```react
(?<=王).+
```

#### 3.3.2 反向后行断言

**反向后行断言：**`(?<!表达式)`，指在某个位置向左看，表示所在位置左侧不能匹配`表达式`

例如：如果要取出喜欢两个字，要求喜欢的**前面没有我**，**后面没有你**，这个时候就要这么写：`(?<!我)喜欢(?!你)`。

请使用正则表达式匹配一个`$`符号中的数据。

> 要匹配 `$` 符号记得加上转义符 `\` 哦

```
需要匹配的
  $ a = a^2 $
  $123$
  $ A = a / b + b $
  $ a = a^2 $
  $123$
  $ A = a / b + b $
  $ a^{2}+ 3\frac{2}{3} $
  $ a**N&123% $

不能匹配的
  abc$asddadd$$
  $$$ a=b^2 $$
  abc$asddadd$$
  abc$ a=b^2 $$abc
  abc$$ a = a**2 $$
  $$ a=b^2 $$
  abc$asddadd$$
  $$$ a=b^2 $$$$
```

```react
(?<!\$)\$[^\$]+\$(?!\$)
```

#### 3.3.3 匹配两个美元符号中的数据

请使用正则表达式匹配所有两个`$`符号中的数据。

```
需要匹配的
  $$ a = a^2 $$
  $$123$$
  $$ A $$
  $$ a = a^2 $$
  $$123$$
  $$ A = a/$$
  $$ a^{2}+ 3\$$
  $$ 9999 $$
  $$ 0987 $$
  $$3\frac{2}$$
  
不能匹配的
  abc$asddadd$$
  $$$ a=b^2 $$
  abc$asddadd$$
  $asddadd$
  $ b = a ^ 2$
  abc$ a=b^2 $$abc
  abc$$$ a = a**2 $$
  $$$$ a=b^2 $$
  abc$asddadd$$￥
  $$$a=b^2 $$$$
```

```react
(?<!\$)\$\$[^\$]+\$\$(?!\$)
```

### 3.4 总结与实践

#### 3.4.1 实践：提取所有人的生日

提取下列数据中所有人的生日，使用两个分组，第一个分组提取“月”，第二个分组提取“日”。

```
需要匹配的
  张伟 1996.8.24
  王伟 1993年1月2日
  王芳 1997-7-24
  李伟 1996.3.21
  王英 1991.12.1
  李秀 1994-7-5
  李娜 1993年1月6日
  
需要提取的
  8 24
  1 2
  7 24
  3 21
  12 1
  7 5
  1 6
```

```react
\d{4}[年.\-](\d{1,2})[月\-.](\d{1,2})
```

#### 3.4.2 实践：匹配所有小数

请编写正则表达式匹配所有的小数：

```
需要匹配的
  0.1
  3.5
  1.34
  2.56
  1.24
  0.123
  77.87
  192.168
  3.1415926
  
不能匹配的
  1
  12
  123
  999
  123456
  12.12.12.
  .12
  .10
  1.1.1.1
```

```react
^\d+\.\d+$
```

```react
(?<!\.)\d+\.(?<=\.)\d+(?!.*\.)
```



## 4. 正则表达式通关挑战

### 4.1 匹配所有XML标签

```
需要匹配的
  <city>hello</city>
  <info>haha</info>
  <div>code</div>
  <table>jn</table>
  
不能匹配的
  <city>hello</cite>
  <info>haha</inf>
  <div>code</dia>
  <table>jn</tbble>
```

```react
<(\w+)>.*</\1>
```

### 4.2 提取所有标题

### 4.3 匹配变量

### 4.4 匹配有规律的单词

### 4.5 匹配不能以0开头的数据

### 4.6 提取所有薪资

### 4.7 匹配邮箱号

### 4.8 匹配质数个的X



