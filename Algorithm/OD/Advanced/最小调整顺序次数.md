# 最小调整顺序次数

## 题目描述

给定一个队列，但是这个队列比较特殊，可以从头部添加数据，也可以从尾部添加数据，但是只能从头部删除数据，输入一个数字n，会依次添加数字1~n（也就是添加n次）。
但是在添加数据的过程中，也会删除数据，要求删除必须按照1～n按照顺序进行删除，所以在删除时，可以根据需要调整队列中数字的顺序以满足删除条件。输入描述：
第一行一个数据N，表示数据的范围。
接下来的2N行是添加和删除语句Q。其中；head add x表示从头部添加元素X，tail add表示从属部添加元素，remove表示删除元素。输出描述：
输出一个数字，表示最小的调整顺序次数。
示例：
5
 head add 1 
tail add 2 
remove head add 3
 tail add 4 
head add 5
 remove
 remove
 remove
 remove 
输出：1
说明：
第1步：【1】
第2步：【1，2】
第3步：头部删除1，无需调整，还剩【2】
第4步：【3，2】
第5步：【3，2，4】
第6步：【5，3，2，4】
第7步：头部删除2，调整顺序再删除，还剩3，4，5】
第8步：头部删除3，无需调整，还剩【4，5】第9步：头部删除4，无需调整，还剩【5】
第10步：头部删除5，无需调整只需要调整1次

## 解题思路

1：按照题目要求模拟整个过程即可，可能需要熟悉的就是dequeQ双端队列这个数据结构。

## 代码

```c++
#include<iostream>
#include<vector>
#include<stdlib.h>
#include<algorithm>
#include<string.h>
#include<exception> 
#include<map>
#include<cmath>
#include<unordered_map>
#include<set>
#include<climits>
#include<ctype.h>
#include<queue>
#include<stack>
#include<list>
#include<bitset>
using namespace std;
 
vector<string> split(string input_str) {
    //空格分割
    vector<string> v;
    while (input_str.find(" ") != string::npos) {
        int found = input_str.find(" ");
        v.push_back(input_str.substr(0, found));
        input_str = input_str.substr(found + 1);
    }    
    v.push_back(input_str);
    return v;
}
 
int main() {
    string input_number;
    getline(cin,input_number);
    int number = stoi(input_number);
 
    vector<vector<string>> operations;
    for (int i =0;i<2*number;i++) {
        string input_str;
        // 带空格的字符串输入
        getline(cin,input_str);
        operations.push_back(split(input_str));
    }
    //for (auto x : operations) {
    //    for (auto y : x) {
    //        cout << y << " ";
    //    }
    //    cout <<"end"<< endl;
    //}
    
    deque<int> num_deque;
    int start = 1;
    int count = 0;//这个是移动次数
    for(int j = 0;j<operations.size();j++){
        vector<string> strs = operations[j];
       
        //如果是移除指令
        if(strs[0] == "remove") {
            if(!num_deque.empty()){
                if(num_deque.front()==start){
                    //如果队列不为空，且移除来的就是start那么可以移除
                    num_deque.pop_front();
                    start++;
                }else{
                    //此时就需要移动了
                    sort(num_deque.begin(), num_deque.end());
                    num_deque.pop_front();
                    count++;
                    start++;
                }
            }
            continue;
        }
 
        //如果是添加指令
        if(strs[1] == "add") {
            if(strs[0] == "head") {
                //从头部添加
                num_deque.push_front(stoi(strs[2]));
            }else{
                //从尾部添加
                num_deque.push_back(stoi(strs[2]));
            }
        }
            
    }
    cout <<count;
    
 
 return 0;
}
```

