# 单项链表中间节点

## 题目描述

题目描述
求单向链表Q中间的节点值，如果奇数个节点取中间，偶数个取偏右边的那个值。
输入描述：
第一行链表头节点地址path后续输入的节点数n
后续输入每行表示一个节点，格式："节点地址 节点值 下一个节点地址（-1表示空指针）"输入保证链表不会出现环，并且可能存在一些节点不属于链表。
输出描述：
链表中间节点值。
测试用例：
输入：
00010 4
00000 3 -1 
00010 5 12309 
11451 6 00000 
12309 7 11451 
输出：
6

## 解题思路

1：第一步，根据输入，构建一个输入节点的列表，用map来保存。
2：第二步，根据输入的头节点，先遍历一次，剔除无效节点并记录链表长度size。
3：第三步，找下标为size/2的节点。

## 代码

```c++
#include<iostream>
#include<vector>
#include<stdlib.h>
#include<algorithm>
#include<string.h>
#include<exception> 
#include<map>
#include<cmath>
#include<unordered_map>
#include<set>
#include<climits>
#include<ctype.h>
#include<queue>
#include<stack>
#include<list>
using namespace std;
 
//链表节点
struct ListNode {
    int val;
    int next;
    ListNode(int val, int next) {
        this->val = val;
        this->next = next;
    }
};
 
int main() {
    //处理输入
    int head_addr;
    int n;
    cin >> head_addr >> n;
    //key为节点值，value为节点
    unordered_map<int, ListNode*> mp;
    for (int i = 0; i < n; i++) {
        int addr, val, next;
        cin >> addr >> val >> next;
        mp[addr] = new ListNode(val, next);
    }
 
    // 构造链表，剔除无效节点
    int size = 1, cur = 0;
    ListNode* head = mp[head_addr];
    ListNode* thead = head;
    while (thead->next != -1) {
        size++;
        thead = mp[thead->next];
    }
 
    // 找中间节点
    while (head->next != -1) {
        if ((size / 2) == cur) {
            cout << head->val;
            return 0;
        }
        head = mp[head->next];
        cur++;
    }
    return 0;
}
```

