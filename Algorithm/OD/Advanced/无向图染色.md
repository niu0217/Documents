# 无向图染色

## 题目描述

给一个无向图Q染色，可以填红黑两种颜色，必须保证相邻两个节点不能同时为红色，输出有多少种不同的染色方蜜？
输入描述：
第一行输入M（图中节点数）N（边数）
后续N行格式为：V1V2表示一个V1到V2的边。
数据范围：1<=M<=15，0<=N<=M*3，不能保证所有节点都是连通的。
输出描述：
输出一个数字表示染色方案的个数。
示例1：
输入：
4 4 
1 2 
2 4 
3 4 
1 3 
输出：
7
说明：4个节点，4条边，1号节点和2号节点相连，2号节点和4号节点相连，3号节点相4号节点相连，1号节点和3号节点相连，若想必须保证相邻两个节点不能同时为红色，总共7种方案。

## 解题思路

1：数据范围比较小，因此可以考虑暴力破解的方式。
2：图类似的题目，基本就是考察节点和边的处理方式。
节点的表达方式：int->二进制数字。举例：11000101，1表示红色，0表示黑色
边的表达方式：pair<int，int>表示两个节点之间相连，存到数组中。
3：有了节点和边，直接遍历所有的可能表达方式即可

## 代码

```c++
#include<iostream>
#include<vector>
#include<stdlib.h>
#include<algorithm>
#include<string.h>
#include<exception> 
#include<map>
#include<cmath>
#include<unordered_map>
#include<set>
#include<climits>
#include<ctype.h>
#include<queue>
#include<stack>
#include<list>
using namespace std;
 
int main() {
    //处理输入
    int m, n;
    cin >> m >> n;
    vector<pair<int, int>> edges;
    for (int i = 0; i < n; i++) {
        int a, b;
        cin >> a >> b;
        edges.push_back(make_pair(a, b));
    }
 
    int count = 0;
    //遍历所有可能的组合 10001 -> i 的二进制表达
    for (int i = 0; i < (1 << m); i++) {
        bool flag = 1;
        // 检测所有的边相连的是否同为红颜色
        for (auto edge : edges) {
            if (((i >> (m-edge.first)) & 1) && ((i >> (m-edge.second)) & 1)) {
                flag = false;
                break;
            }
        }
        if(flag) {
            count++;
        }
    }
    cout << count;
    return 0;
}
```

