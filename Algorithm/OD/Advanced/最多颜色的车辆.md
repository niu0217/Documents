# 最多颜色的车辆

## 题目描述

题目内容
在一个狭小的路口，每秒只能通过一辆车，假好车辆的颜色只有3种，找出N秒内经过的最多颜色的车辆数量。三种颜色编号为0，1，2
输入描述
第一行输入的是通过的车辆颜色信息
【0，1，1，2】代表4秒钟通过的车辆颜色分别是0，1，1，2
第二行输入的是统计时间窗，整型，单位为秒
输出描述
输出指定时间窗内经过的最多颜色的车辆数量。
样例

样例一：
输入
0 1 2 1
3
输出 
2 
样例解释
在3秒时间窗内，每个颜色最多出现2次。例为：【1，2，1】
样例二：
输入
0 1 2 1
2 
输出
1 
样例解释
在2秒时间窗内，每个颜色最多出现1次。

## 解题思路

1：个人觉得这个题的难点就在题目理解上，说一个滑动窗口的话，大家应该就都理解了，给一个数组，一个周定大小的语动窗口，一直向前滑动，找出这个滑动窗口内出现最多的数字的个数。
2：可以用一个hashmap保存滑动窗口的数据来统计即可。但是每次滑动之后还需要对hashmap按照Value的大小再排序，那这样的复杂度就比较高了。但是暴力解法应该也能过个70%、80%吧
3：这里有一个巧妙的方法，既然只有三种颜色的车，那么我们岂不是只需要一个长度为3的数组来保存每个颜色出现的次数就行了，数组的下标表示颜色，数组中存的值表示出现次数。这样三个数来比较，应该快多了。用数组来替代hashmap。

## 代码

```c++
#include<iostream>
#include<vector>
#include<stdlib.h>
#include<algorithm>
#include<string.h>
#include<exception> 
#include<map>
#include<cmath>
#include<unordered_map>
#include<set>
#include<climits>
#include<ctype.h>
#include<queue>
#include<stack>
#include<list>
using namespace std;
 
int main() {
    //处理输入
    string input_str;
    getline(cin ,input_str);
    string window_str;
    getline(cin, window_str);
    int window_size = stoi(window_str);
    vector<int> cars;
    while (input_str.find(" ") != string::npos) {
        int found = input_str.find(" ");
        cars.push_back(stoi(input_str.substr(0, found)));
        input_str = input_str.substr(found + 1);
    }    
    cars.push_back(stoi(input_str));
 
    // 初始化滑动窗口
    vector<int> car_count = vector<int>(3, 0); 
    for (int i=0;i<window_size;i++) {
        car_count[cars[i]] += 1;
    }
 
    //滑动窗口向前滑
    int max_res = max(max(car_count[0], car_count[1]), car_count[2]);
    for (int i = window_size; i < cars.size(); i++) {
        car_count[cars[i]] += 1;
        car_count[cars[i-window_size]] -= 1;
        max_res = max(max_res, max(max(car_count[0], car_count[1]), car_count[2]));
    }
    cout << max_res << endl;
    
    return 0;
}
```

