# 过滤组合字符串

## 题目描述

数字0、1、2、3、4、5、6、7、8、9分别关联 a~z 26个英文字母。
0关联"a"，"b"，"c"
1关联"d"，"e"，"f"
2关联"g"，"h"，"i"
3关联”J“，”k”，“T”
4关联"m"，"n"，"o"
5关联"p"，"q"，"r"
6关联"s"，"t"
7关联"u"，"V"
8关联"w"，"x"
9关联"y"，"z"
例如7关联"u"，"V"，8关联"×"，"w"，输入一个字符串例如"78"，
和一个屏蔽字符串“Ux'，那么'78'可以组成多个字符串例如：“ux'，“uw'，“ww\”，过滤这些完全包含屏蔽字符串的每一个字符的字符串，然后输出剩下的字符串。
示例：输入：78 UX 输出：UW VX VW
说明：ux完全包含屏蔽字符串ux，因此剔除

## 解题思路

1：一个map来保存所有的数字及其关联的英文字母。
2：先遍历求出所有的组合，然后利用string的find函数Q即可判定是否完全包含。

## 代码

```c++
#include<iostream>
#include<vector>
#include<stdlib.h>
#include<algorithm>
#include<string.h>
#include<exception> 
#include<map>
#include<cmath>
#include<unordered_map>
#include<set>
#include<climits>
#include<ctype.h>
#include<queue>
#include<stack>
#include<list>
#include<bitset>
using namespace std;
 
//递归求出所有组合
void dfs(vector<string>& res_list, string num_str, string& temp_str, int index, map<char, string> num_char_map) {
    if(index == num_str.size()){
        res_list.push_back(temp_str);
        return;
    }
    for (auto single_char : num_char_map[num_str[index]]) {
        temp_str += single_char;
        dfs(res_list, num_str,temp_str,index+1,num_char_map);
        temp_str = temp_str.substr(0, index);
    }
}
 
int main() {
    //预设值
    map<char, string> num_char_map;
 
    num_char_map['0'] = "abc";
    num_char_map['1'] = "def";
    num_char_map['2'] = "ghi";
    num_char_map['3'] = "jkl";
    num_char_map['4'] = "mno";
    num_char_map['5'] = "pqr";
    num_char_map['6'] = "st";
    num_char_map['7'] = "uv";
    num_char_map['8'] = "wx";
    num_char_map['9'] = "yz";
 
    //处理输入
    string num_str, block_str;
    cin >> num_str >> block_str;
 
    vector<string> res_list;
    string temp_str = "";
    dfs(res_list, num_str, temp_str, 0, num_char_map);
 
    int result_count = res_list.size();
    for (auto x : res_list) {
        //cout << x << endl;
        if (x.find(block_str) != string::npos) {
            result_count -= 1;
        }
    }
    cout << result_count;
    
    return 0;
}
```

