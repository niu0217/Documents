# 真正的密码

## 题目描述

在一行中输入一个字符串数组Q，如果其中一个字符串的所有以索引O开头的子串在数组中都有，那么这个字符串就是潜在密码，在所有潜在密码中最长的是真正的密码，如果有多个长度相同的真正的密码，那么取字典序最大的为唯一的真正的密码，求唯一的真正的密码。
示例1：
输入：  h he hel hell hello o ok n ni nin ninj ninja
输出： ninja
说明：按要求，hello、ok、ninja都是潜在密码。检查长度，hello、ninja是真正的密码。检查字典序，ninja是唯一真正密码。
示例2：
输入：a b c d f
输出：f
说明：按要求，a b c d f都是潜在密码。检查长度，a b c d f是真正的密码。检查字典序，f是唯一真正密码。

## 解题思路

1：利用set将字符串查找操作的时间复杂度降低，然后按照题目要求的几个条件取出真正的密码即可。

## 代码

```c++
#include<iostream>
#include<vector>
#include<stdlib.h>
#include<algorithm>
#include<string.h>
#include<exception> 
#include<map>
#include<cmath>
#include<unordered_map>
#include<set>
#include<climits>
#include<ctype.h>
#include<queue>
#include<stack>
#include<list>
#include<bitset>
using namespace std;
 
int main() {
    string input_str;
    // 带空格的字符串输入
    getline(cin,input_str);
    
    //空格分割
    vector<string> v;
    while (input_str.find(" ") != string::npos) {
        int found = input_str.find(" ");
        v.push_back(input_str.substr(0, found));
        input_str = input_str.substr(found + 1);
    }    
    v.push_back(input_str);
 
    // 将所有字符串放入哈希集合
    set<string> word_set;
    for (auto s : v) {
        word_set.insert(s);
    }
 
    // 真正的密码
    string true_pass_word="";
 
    //按顺序检查每一个词
    for (auto s : v) {
        // 条件1：检查这个词所有以索引0开头的子串在数组中是否都有
        bool flag=true;
        for(int i=1;i<s.length();i++){
            // 以索引0开头的子串
            string sub_str=s.substr(0,i);
            if(!word_set.count(sub_str)){
                flag=false;
                break;
            }
        }
    
        if(flag){
            // 条件2：比较密码长度
            if(s.size()>true_pass_word.size())
                true_pass_word=s;
            // 条件3：比较密码字典排序
            if(s.size()==true_pass_word.size()&& s>true_pass_word){
                true_pass_word=s;
            }
        }
    }
 
    cout << true_pass_word;
 
 return 0;
}
```

