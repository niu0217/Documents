# 租车骑绿岛

## 题目描述

【租车骑绿岛】100分
部门组织绿岛骑行团建活动。租用公共双人自行车，每辆自行车最多坐两人，做最大载重M。给出部门每个人的体重，请问最多需要租用多少双人自行车。
输入描述：
第一行两个数字m、n，分别代表自行车限重，部门总人数。
第二行，n个数字，代表每个人的体重，体重都小于等于自行车限重m。
0<m<=200 
0<n<=1000000 
输出描述：
最小需要的双人自行车数量。

示例1输入输出示例仅供调试，后台判题数据一般不包含示例输入
3 4
3 2 2 1
输出
3

## 解题思路

1：题目中有两个隐含的条件：1、一辆车最多骑两个人2、人的重量不可能大于车的载重
2：那么可以用两个指针，一个指向头部left，一个指向尾部right，如果w【left】+w【right】>车的载重，那么意味着最重的人，加上最轻的人都会超载，只能他一个人骑，right--。
如果w（lef】 +w【right】<=车的载重，那么意味着这两个人可以还可以再加人，left ++继续判断直到总重量>车的蛾重。

## 代码

```c++
#include<iostream>
#include<vector>
#include<stdlib.h>
#include<algorithm>
#include<string.h>
#include<exception> 
#include<map>
#include<cmath>
#include<unordered_map>
#include<set>
#include<climits>
#include<ctype.h>
#include<queue>
#include<stack>
#include<list>
#include<bitset>
using namespace std;
 
vector<string> split(string input_str) {
    vector<string> v;
    while (input_str.find(" ") != string::npos) {
        int found = input_str.find(" ");
        v.push_back(input_str.substr(0, found));
        input_str = input_str.substr(found + 1);
    }    
    v.push_back(input_str);
    return v;
}
 
template<typename T>
struct comp {
  bool operator() (const pair<T,T>& pair_1, const pair<T,T>& pair_2) const
  {    return (pair_1.first > pair_2.first) || ((pair_1.first == pair_2.first)&&(pair_1.second < pair_2.second)); }
};
 
 
int main() {
    // 处理输入
    int m,n;
    cin >> m >> n;
    
    vector<int> weights;
    for (int i=0;i<n;i++) {
        int a;
        cin >> a;
        weights.push_back(a);
    }
    
    //第一步，排序
    sort(weights.begin(), weights.end());
    
 
    //第二步，左右指针向中间移动
    int left=0;
    int right = weights.size()-1;
 
    //结果
    int min_bikes = 0;
 
    //当前重量
    int temp_weight = weights[right] + weights[left]; 
    
    // 题目中有两个隐含的条件
    // 1: 一辆车最多骑两个人
    // 2：人的重量不可能大于车的载重
    
    while(left<right) {
        if (temp_weight > m) {
            right --;
            min_bikes += 1;
            temp_weight = weights[right] + weights[left];
        } else{
            right --;
            left ++;
            min_bikes += 1;
            temp_weight = weights[right] + weights[left];
        } 
    }
 
    // 感谢评论区老铁点拨
    if (left == right) {
        min_bikes++;
    }
 
    cout << min_bikes;
    return 0;
}
```

